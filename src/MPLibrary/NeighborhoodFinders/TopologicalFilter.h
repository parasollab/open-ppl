#ifndef TOPOLOGICAL_FILTER_H_
#define TOPOLOGICAL_FILTER_H_

#include "NeighborhoodFinderMethod.h"

#include "MPLibrary/MapEvaluators/RRTQuery.h"

#include <boost/heap/fibonacci_heap.hpp>


////////////////////////////////////////////////////////////////////////////////
/// Filters the roadmap for a set of topologically relevant candidate neighbors.
/// Choosing from amongst the candidates is then delegated to another
/// neighborhood finder.
///
/// @WARNING This must be used with a free-space sampler. At least the reference
///          point must be in free space for this object to be helpful.
///
/// @TODO If performance is poor, try caching the N most recently used lookups.
////////////////////////////////////////////////////////////////////////////////
template <typename MPTraits>
class TopologicalFilter : public NeighborhoodFinderMethod<MPTraits> {

  public:

    ///@name Motion Planning Types
    ///@{

    typedef typename MPTraits::CfgType                CfgType;
    typedef typename MPTraits::RoadmapType            RoadmapType;
    typedef typename RoadmapType::GraphType           GraphType;
    typedef typename GraphType::VID                   VID;
    typedef WorkspaceDecomposition::vertex_descriptor VD;
    typedef WorkspaceDecomposition::edge_descriptor   ED;

    ///@}
    ///@name Construction
    ///@{

    TopologicalFilter();

    TopologicalFilter(XMLNode& _node);

    virtual ~TopologicalFilter() = default;

    ///@}
    ///@name MPBaseObject Overrides
    ///@{

    /// Compute the SSSP scores over the decomposition starting from the goal
    /// region.
    virtual void Initialize() override;

    void Print(std::ostream& _os) const override;

    ///@}
    ///@name NeighborhoodFinder Functions
    ///@{

    /// Filter the candidate range. Pass only the topologically relevant
    /// candidates to the underlying NF.
    template <typename InputIterator, typename OutputIterator>
    OutputIterator FindNeighbors(RoadmapType* _rmp,
        InputIterator _first, InputIterator _last, bool _fromFullRoadmap,
        const CfgType& _cfg, OutputIterator _out);

    /// For each vertex in one range, call the underlying NF only on those
    /// vertices in the second range which are topological candidates.
    template <typename InputIterator, typename OutputIterator>
    OutputIterator FindNeighborPairs(RoadmapType* _rmp,
        InputIterator _first1, InputIterator _last1,
        InputIterator _first2, InputIterator _last2,
        OutputIterator _out);

    ///@}

  private:

    ///@name Candidate Neighbors
    ///@{

    /// Find the candidate regions for connecting to a given configuration.
    /// @param _cfg The configuration we wish to connect to.
    /// @return The set of regions that hold candidate neighbors for _cfg.
    std::vector<const WorkspaceRegion*> FindCandidateRegions(const CfgType& _cfg)
        const;

    /// Scan back along the child map and find the minimal set of all regions
    /// which are populated and reachable via the SSSP subtree from _root.
    /// @param _root The SSSP subtree root.
    /// @return The set of populated regions that form a frontier in the
    ///         subtree. These will be sorted according to decreasing subtree
    ///         depth (so nodes closer to the goal are towards the end).
    std::vector<VD> ComputePopulatedFrontier(const VD _root) const;

    /// Compute the intersection of an input set with a set of candidate
    /// neighbors.
    /// @param _first The beginning of the input range.
    /// @param _last  The end of the input range.
    /// @param _candidates The candidate set.
    /// @return A set of VIDs that are present in both the input range and
    ///         candidate set.
    template <typename InputIterator>
    std::vector<VID> ComputeIntersection(InputIterator _first,
        InputIterator _last, const std::vector<VID>& _candidates) const;

    ///@}
    ///@name Helpers
    ///@{

    void LazyInitialize();

    /// After literally hours of trying to get STAPL's dijkstra_sssp to work with
    /// custom maps, I'm calling that impossible and writing my own. This should
    /// have taken 10 minutes with a proper API.
    void ComputeSSSP(const WorkspaceRegion& _region);

    ///@}
    ///@name Internal State
    ///@{

    std::string m_nfLabel; ///< The underlying neighborhood finder label.
    std::string m_tmLabel; ///< The topological map label.

    /// The SSSP scores generated by searching outward from the goal.
    std::unordered_map<VD, double> m_scores;

    /// A map from parent -> child in the SSSP tree.
    /// @TODO We maybe don't need this, leaving it in until I'm sure.
    std::unordered_map<VD, std::vector<VD>> m_childMap;

    /// A topological sort DAG using the SSSP scores. This is like the SSSP
    /// tree with cross-edges.
    std::unordered_map<VD, std::vector<VD>> m_dagMap;

    double m_backtrackDistance; ///< The distance to back track along cells.

    bool m_fallback{false}; ///< Fall back to the underlying NF on fail?

    bool m_fromPopulated{false}; ///< Start search from the populated frontier?

    bool m_initialized{false}; ///< Is this object ready to use?

    ///@}
};

/*------------------------------- Construction -------------------------------*/

template <typename MPTraits>
TopologicalFilter<MPTraits>::
TopologicalFilter() : NeighborhoodFinderMethod<MPTraits>() {
  this->SetName("TopologicalFilter");
}


template <typename MPTraits>
TopologicalFilter<MPTraits>::
TopologicalFilter(XMLNode& _node)
    : NeighborhoodFinderMethod<MPTraits>(_node, false) {
  this->SetName("TopologicalFilter");

  m_nfLabel = _node.Read("nfLabel", true, "", "Label for the underlying NF.");

  m_tmLabel = _node.Read("tmLabel", true, "", "Label for the topological map.");

  m_backtrackDistance = _node.Read("backtrackDistance", true, 0., 0.,
      std::numeric_limits<double>::max(),
      "Maximum distance to backtrack along the decomposition cells. Use the "
      "most conservative value that reliably finds configurations.");

  m_fallback = _node.Read("fallback", false, m_fallback,
      "Fall back to the underlying NF when no candidates are found. This helps "
      "with getting started, but can also cause a loss of benefit in large "
      "workspaces where it takes a long time to cover the space.");

  m_fromPopulated = _node.Read("fromPopulated", false, m_fromPopulated,
      "Find the set of populated cells that form the frontier, and start the "
      "search from each one.");
}

/*--------------------------- MPBaseObject Overrides -------------------------*/

template <typename MPTraits>
void
TopologicalFilter<MPTraits>::
Initialize() {
  m_initialized = false;
}


template <typename MPTraits>
void
TopologicalFilter<MPTraits>::
Print(std::ostream& _os) const {
  NeighborhoodFinderMethod<MPTraits>::Print(_os);
  _os << "\tnfLabel: " << m_nfLabel
      << "\ttmLabel: " << m_tmLabel
      << "\n\tBacktrack distance: " << m_backtrackDistance
      << std::endl;
}

/*----------------------- NeighborhoodFinder Functions -----------------------*/

template <typename MPTraits>
template <typename InputIterator, typename OutputIterator>
OutputIterator
TopologicalFilter<MPTraits>::
FindNeighbors(RoadmapType* _rmp,
    InputIterator _first, InputIterator _last, bool _fromFullRoadmap,
    const CfgType& _cfg, OutputIterator _out) {
  LazyInitialize();

  auto stats = this->GetStatClass();
  MethodTimer mt(stats, "TopologicalFilter::FindNeighbors");

  // This object only works on the free space roadmap right now. It could be
  // expanded to handle other maps if we want, but for now we will crash if this
  // isn't the free space.
  if(_rmp != this->GetRoadmap())
    throw RunTimeException(WHERE, "Only works on the free space at this time.");

  if(this->m_debug)
    std::cout << "TopologicalFilter::FindNeighbors\n";

  auto tm = this->GetMPTools()->GetTopologicalMap(m_tmLabel);
  auto nf = this->GetNeighborhoodFinder(m_nfLabel);

  // Find the topological candidate vertices.
  std::vector<const WorkspaceRegion*> regions = FindCandidateRegions(_cfg);
  std::vector<VID> topologicalCandidates = tm->GetMappedVIDs(regions);

  // Find the vertices that are in both the input set and topological
  // candidates.
  std::vector<VID> candidates;
  if(_fromFullRoadmap)
    candidates = std::move(topologicalCandidates);
  else
    candidates = ComputeIntersection(_first, _last, topologicalCandidates);

  // If we found no candidates, report fail or fall back to underlying NF.
  if(candidates.empty()) {
    // Distinguish between the two types of no-candidate scenarios.
    if(topologicalCandidates.empty()) {
      stats->IncStat("TopologicalFilter::NoTopologicalCandidates");

      if(this->m_debug)
        std::cout << "No vertices found in candidate cells."
                  << std::endl;
    }
    else {
      stats->IncStat("TopologicalFilter::NoInputCandidates");

      if(this->m_debug)
        std::cout << "Found " << topologicalCandidates.size() << " vertices in "
                  << "candidate cells, but none were in the input range."
                  << std::endl;
    }

    // Fall back to underlying NF if that option is selected.
    if(m_fallback) {
      if(this->m_debug)
        std::cout << "\tFalling back to underlying nf '" + m_nfLabel + "'."
                  << std::endl;

      nf->FindNeighbors(_rmp, _first, _last, _fromFullRoadmap, _cfg, _out);
    }
    return _out;
  }

  // Call the underlying NF on the reduced candidate set..
  nf->FindNeighbors(_rmp, candidates.begin(), candidates.end(),
      candidates.size() == this->GetRoadmap()->GetGraph()->get_num_vertices(),
      _cfg, _out);

  // Track information on average candidate set size.
  const double count = stats->GetStat("TopologicalFilter::UsedCandidates"),
               avg = stats->GetStat("TopologicalFilter::AvgCandidates");

  stats->IncStat("TopologicalFilter::UsedCandidates");
  stats->SetStat("TopologicalFilter::AvgCandidates",
      (avg * count + candidates.size()) / (count + 1));

  if(this->m_debug)
    std::cout << "Used candidate set."
              << "\n\tInput Vertices: " << std::distance(_first, _last)
              << "\n\tCandidates Vertices: " << candidates.size()
              << "\n\tCandidate Regions: " << regions.size()
              << std::endl;

  return _out;
}


template <typename MPTraits>
template <typename InputIterator, typename OutputIterator>
OutputIterator
TopologicalFilter<MPTraits>::
FindNeighborPairs(RoadmapType* _rmp,
    InputIterator _first1, InputIterator _last1,
    InputIterator _first2, InputIterator _last2,
    OutputIterator _out) {
  throw RunTimeException(WHERE, "Not yet implemented. We need to think about "
      "how this should work - I.e., do we imply an ordering on the neighbor "
      "pairs (A, B) such that B is a topological neighbor A but not vis versa?");
  return _out;
}

/*---------------------------- Candidate Neighbors ---------------------------*/

template <typename MPTraits>
std::vector<const WorkspaceRegion*>
TopologicalFilter<MPTraits>::
FindCandidateRegions(const CfgType& _cfg) const {
  MethodTimer mt(this->GetStatClass(), "TopologicalFilter::FindCandidateRegions");

  if(this->m_debug)
    std::cout << "Locating regions for cfg at " << _cfg.GetPoint()
              << std::endl;

  auto decomposition = this->GetEnvironment()->GetDecomposition();

  // Find the cell that _cfg lives in.
  auto tm = this->GetMPTools()->GetTopologicalMap(m_tmLabel);
  const WorkspaceRegion* rootRegion = tm->LocateRegion(_cfg);

  // Check for invalid region. If so, _cfg is in obstacle space. Don't bother
  // trying to locate the nearest - tried that and it's too expensive.
  /// @TODO Figure out a better answer than guessing/failing here.
  if(!rootRegion)
    return {};

  // The candidate regions.
  std::vector<const WorkspaceRegion*> candidates;

  // Track whether nodes were used in any search.
  std::unordered_map<VD, bool> used;

  // Each time we start a search, we set a new base and maximum score.
  double baseScore, maxScore;

  // Define a recursive function to get the candidate regions.
  std::function<void(const VD)> collectCandidates([&](const VD _current) -> void {
    // Skip nodes we've already used.
    if(used.count(_current))
      return;

    // Add this region to the candidates.
    used[_current] = true;
    candidates.push_back(&decomposition->GetRegion(_current));

    if(this->m_debug)
      std::cout << "\tRegion " << _current
                << ", distance: "
                << std::setprecision(4) << m_scores.at(_current)
                << ", from search root: "
                << std::setprecision(4)
                << m_scores.at(_current) - baseScore
                << std::endl;

    // If this node is over the limit or has no children, we're done with it.
    if(m_scores.at(_current) > maxScore or !m_dagMap.count(_current))
      return;

    // Starting from the current region, scan outwards along the child map for
    // regions within the backtrack distance.
    for(VD child : m_dagMap.at(_current)) {
      // If we already used this node, move on.
      if(used.count(child))
        continue;

      collectCandidates(child);
    }
  });

  // Determine the search frontier.
  auto root = decomposition->GetDescriptor(*rootRegion);
  std::vector<VD> frontier = m_fromPopulated ? ComputePopulatedFrontier(root)
                                             : std::vector<VD>{root};

  // While the queue isn't empty, collect candidates from the next closest
  // frontier node.
  for(const VD current : frontier) {
    // Compute new base and limit.
    baseScore = m_scores.at(current);
    maxScore  = baseScore + m_backtrackDistance;

    if(this->m_debug)
      std::cout << "\n\tSearching from root VD: " << current
                << (m_dagMap.count(current) ? "" : " (leaf)")
                << "\n\t\tRoot distance: " << baseScore
                << ", Back track distance: " << m_backtrackDistance
                << ", Max distance: " << maxScore
                << std::endl;

    // Start this search.
    collectCandidates(current);
  }

  return candidates;
}


template <typename MPTraits>
std::vector<typename TopologicalFilter<MPTraits>::VD>
TopologicalFilter<MPTraits>::
ComputePopulatedFrontier(const VD _root) const {
  MethodTimer mt(this->GetStatClass(),
      "TopologicalFilter::ComputePopulatedFrontier");

  auto tm = this->GetMPTools()->GetTopologicalMap(m_tmLabel);
  auto decomposition = this->GetEnvironment()->GetDecomposition();

  std::unordered_map<VD, bool> populated;
  std::vector<VD> result;
  std::queue<VD> frontier;
  frontier.push(_root);

  while(!frontier.empty()) {
    // Get the next node.
    const VD current = frontier.front();
    frontier.pop();

    // We've already checked this node if it's populated value is set.
    if(populated.count(current))
      continue;

    populated[current] = tm->GetMappedVIDs(&decomposition->GetRegion(current)).
        size();

    // If the node is populated, add it to the result set.
    if(populated[current])
      result.push_back(current);
    // If the node is not populated, add its children to the search frontier.
    else if(m_dagMap.count(current))
      for(VD child : m_dagMap.at(current))
        frontier.push(child);
    // Else this is an unpopulated leaf.
  }

  // Sort the result set according to decreasing SSSP score.
  std::sort(result.begin(), result.end(),
      [&](const VD& _a, const VD& _b) {
        return m_scores.at(_a) > m_scores.at(_b);
      });

  return result;
}


template <typename MPTraits>
template <typename InputIterator>
std::vector<typename TopologicalFilter<MPTraits>::VID>
TopologicalFilter<MPTraits>::
ComputeIntersection(InputIterator _first, InputIterator _last,
    const std::vector<VID>& _candidates) const {
  if(_candidates.empty())
    return {};

  MethodTimer mt(this->GetStatClass(), "TopologicalFilter::ComputeIntersection");

  // The input range could be VIDs or vertex iterators. Ask the RoadmapGraph for
  // VIDs.
  auto g = this->GetRoadmap()->GetGraph();
  std::vector<VID> inputRange;
  for(auto iter = _first; iter != _last; ++iter)
    inputRange.push_back(g->GetVID(iter));

  // Sort and uniqueify the input set.
  std::sort(inputRange.begin(), inputRange.end());
  std::unique(inputRange.begin(), inputRange.end());

  // Compute the intersection with the candidate set.
  std::vector<VID> intersection;
  intersection.reserve(std::max(inputRange.size(), _candidates.size()));

  std::set_intersection(inputRange.begin(), inputRange.end(),
                        _candidates.begin(), _candidates.end(),
                        std::back_inserter(intersection));

  return intersection;
}

/*---------------------------------- Helpers ---------------------------------*/

template <typename MPTraits>
void
TopologicalFilter<MPTraits>::
LazyInitialize() {
  if(m_initialized)
    return;
  m_initialized = true;

  /// @TODO Support this for RRT and PRM.

  // Get the goal configuration from the query.
  auto query = static_cast<RRTQuery<MPTraits>*>(this->GetMapEvaluator("RRTQuery").
      get());
  const CfgType& goal = query->GetQuery()[1];

  // Find the goal region.
  auto tm = this->GetMPTools()->GetTopologicalMap(m_tmLabel);
  auto goalRegion = tm->LocateRegion(goal);

  // Compute the SSSP scores.
  ComputeSSSP(*goalRegion);
}


template <typename MPTraits>
void
TopologicalFilter<MPTraits>::
ComputeSSSP(const WorkspaceRegion& _goalRegion) {
  MethodTimer mt(this->GetStatClass(), "TopologicalFilter::ComputeSSSP");

  if(this->m_debug)
    std::cout << "TopologicalFilter::ComputeSSSP\n";

  m_scores.clear();
  m_childMap.clear();
  m_dagMap.clear();
  auto decomposition = this->GetEnvironment()->GetDecomposition();

  // Build a weight map to represent the distances between decomposition regions,
  // where the weight between cells is the euclidean distance from cell center ->
  // shared facet center -> cell center.
  std::unordered_map<size_t, double> weights;

  for(auto edge = decomposition->edges_begin();
      edge != decomposition->edges_end(); ++edge) {
    // Ensure there is exactly one facet between each pair of regions.
    WorkspacePortal& portal = edge->property();
    auto facets = portal.FindFacets();
    if(facets.size() > 1)
      throw RunTimeException(WHERE, "This implementation assumes that the "
          "WorkspaceRegions are connected by only one facet. At this time we do "
          "not have any decompositions that need more than this. We can easily "
          "extend this by searching through the possible lengths and choosing "
          "the smallest.");

    // Get the center points of each region and the facet.
    const Point3d facet  = facets[0]->FindCenter(),
                  source = portal.GetSource().FindCenter(),
                  target = portal.GetTarget().FindCenter();

    // Compute the map key and value.
    const double distance = (target - facet).norm() + (facet - source).norm();

    weights[edge->id()] = distance;
  }


  // Define an element in the PQ for dijkstra's.
  struct element {
    VD parent;
    VD vd;
    double distance;

    bool operator>(const element& _e) const {
      return distance > _e.distance;
    }
  };

  // Define a min priority queue for dijkstras. We will not update elements when
  // better distances are found - instead we will track the most up-to-date
  // distance and ignore elements with different values. This is effectively a
  // lazy delete of stale elements.
  std::priority_queue<element,
                      std::vector<element>,
                      std::greater<element>> pq;

  // Initialize visited and temporary distance maps. The later holds an *exact*
  // copy of the most up-to-date distance for each node.
  std::unordered_map<VD, bool> visited;
  std::unordered_map<VD, double> distance;
  for(auto iter = decomposition->begin(); iter != decomposition->end(); ++iter) {
    visited[iter->descriptor()] = false;
    distance[iter->descriptor()] = std::numeric_limits<double>::max();
  }

  // Define a relax edge function.
  auto relax = [&distance, &weights, &pq](const ED& _ed) {
    const double sourceDistance = distance[_ed.source()],
                 targetDistance = distance[_ed.target()],
                 edgeWeight     = weights[_ed.id()],
                 newDistance    = sourceDistance + edgeWeight;

    // If the new distance isn't better, quit.
    if(newDistance >= targetDistance)
      return;

    // Otherwise, update target distance and add the target to the queue.
    distance[_ed.target()] = newDistance;
    pq.push(element{_ed.source(), _ed.target(), newDistance});
  };

  // Initialize the first node.
  const VD root = decomposition->GetDescriptor(_goalRegion);
  distance[root] = 0;
  pq.push(element{root, root, 0});

  // Dijkstras.
  while(!pq.empty()) {
    // Get the next element.
    element current = pq.top();
    pq.pop();

    // If we are done with this node, the element is stale. Discard.
    if(visited[current.vd])
      continue;
    visited[current.vd] = true;

    // Save this score and set the child map.
    m_scores[current.vd] = distance[current.vd];
    m_childMap[current.parent].push_back(current.vd);

    if(this->m_debug)
      std::cout << "\tVertex " << current.vd
                << " has parent " << current.parent
                << ", score " << std::setprecision(4) << m_scores[current.vd]
                << ", and center at "
                << decomposition->GetRegion(current.vd).FindCenter()
                << std::endl;

    // Relax each outgoing edge.
    auto vertexIter = decomposition->find_vertex(current.vd);
    for(auto edgeIter = vertexIter->begin(); edgeIter != vertexIter->end();
        ++edgeIter)
      relax(edgeIter->descriptor());
  }

  // The root was added to its own child map - fix that now.
  auto& rootMap = m_childMap[root];
  rootMap.erase(std::find(rootMap.begin(), rootMap.end(), root));

  // Build the topological sort DAG using SSSP scores as the ordering value.
  for(auto vi = decomposition->begin(); vi != decomposition->end(); ++vi) {
    for(auto ei = vi->begin(); ei != vi->end(); ++ei) {
      const VD source = ei->source(),
               target = ei->target();
      // If the target has a higher score, it is a child in the DAG.
      if(m_scores[source] < m_scores[target])
        m_dagMap[source].push_back(target);
    }
  }
}

/*----------------------------------------------------------------------------*/

#endif
