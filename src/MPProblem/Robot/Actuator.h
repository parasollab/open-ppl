#ifndef ACTUATOR_H_
#define ACTUATOR_H_

#include <iostream>
#include <vector>

#include "Control.h"
#include "Geometry/Boundaries/Range.h"

class btMultiBody;
class Robot;
class XMLNode;


////////////////////////////////////////////////////////////////////////////////
/// Models an actuator on a robot, such as an engine or motor.
///
/// @details Actuators model a means of locomotion for a robot. They accept a
///          control signal and produce a generalized force on one or more of
///          the robot's DOFs. There are limits on the maximum forward/backward
///          force that can be applied to each DOF, and an additional limit on
///          the maximum total force.
///
///          The range of all possible controls that an actuator can accept is
///          represented with a ControlSpace.
///
///          The actuator is also able to apply a control to the simulated robot
///          with the Execute method.
///
/// @warning The max force doesn't distinguish between forces and torques: it is
///          a maximum generalized force. It's unlikely that this object will
///          make much sense if it controls both force DOFs (i.e., translation
///          or prismatic joint extension) and torque DOFs (i.e., rotation and
///          revolute/spherical joints).
////////////////////////////////////////////////////////////////////////////////
class Actuator final {

  public:

    ///@name Local Types
    ///@{

    /// The types of dynamics supported. Force-based actuators exert forces on a
    /// robot, while velocity-based actuators simply set the velocity.
    enum DynamicsType {Force, Velocity};

    ///@}

  protected:

    ///@name Internal State
    ///@{

    Robot* const m_robot;                ///< The owning robot object.

    std::string m_label;                 ///< The unique label for this actuator.

    std::vector<bool> m_mask;            ///< Which DOFs can this affect?
    std::vector<Range<double>> m_limits; ///< Maximum backward/forward force.
    double m_maxForce;                   ///< The largest producible force.

    DynamicsType m_type{Force};          ///< The dynamics type.

    ControlSpace m_controlSpace;      ///< The space of accepted control signals.

    ///@}

  public:

    ///@name Construction
    ///@{

    /// Construct an empty actuator for a given robot.
    /// @param[in] _r The owning robot.
    /// @param[in] _label The actuator label.
    /// @param[in] _t The dynamics type.
    Actuator(Robot* const _r, const std::string& _label,
        const DynamicsType _t = Force);

    /// Construct an actuator for a given robot from an XML input.
    /// @param[in] _r The owning robot.
    /// @param[in] _node The XML input node.
    Actuator(Robot* const _r, XMLNode& _node);

    /// Copy an actuator to another robot.
    /// @param _r The robot which will own the new copy.
    /// @param _a The actuator to copy.
    Actuator(Robot* const _r, const Actuator& _a);

    ///@}
    ///@name Actuator Properties
    ///@{

    /// Set the minimum and maximum generalized forces that this actuator can
    /// apply to any DOF.
    /// @param[in] _min The minimum generalized forces.
    /// @param[in] _max The maximum generalized forces.
    void SetLimits(const std::vector<double>& _min,
        const std::vector<double>& _max);

    /// Set the maximum total generalized force that this actuator can apply.
    /// @param[in] _total The greatest total generalized force that can be
    ///                   applied.
    void SetMaxForce(const double _total);

    ///@}
    ///@name Planning Interface
    ///@{

    /// Get the control mask for this actuator, which indicates the DOFs that it
    /// can affect.
    /// @return A vector with one boolean for each DOF, where true indicates that
    ///         the actuator can affect that DOF.
    std::vector<bool> ControlMask() const;

    /// Compute the force generated by driving the actuator at some fraction of
    /// its total power.
    /// @param[in] _s The control signal to apply.
    /// @return The force generated in the robot's local frame by driving this
    ///         with control signal _s.
    std::vector<double> ComputeForce(const Control::Signal& _s) const;

    /// Compute the best-match signal to get this actuator to produce a given
    /// force.
    /// @param _force The desired force in the robot's local frame.
    /// @return The signal in this actuator's control space that produces the
    ///         effect most similar to _force.
    Control::Signal ComputeNearestSignal(const std::vector<double>& _force) const;

    ///@}
    ///@name Simulation Interface
    ///@{

    /// Apply a control signal to the robot's bullet model.
    /// @param _s The control signal to apply.
    void Execute(const Control::Signal& _s) const;

    /// Apply a control signal to a bullet model of the owning robot.
    /// @param _s The control signal to apply.
    /// @param _model The bullet model of m_robot to control.
    void Execute(const Control::Signal& _s, btMultiBody* const _model) const;

    /// Get the label for this actuator
    std::string GetLabel() const;

    /// Get the robot that the actuator is on
    Robot* GetRobot() const;

    ///@}

  private:

    ///@name Helpers
    ///@{

    /// Compute the space of allowed control signals for this actuator.
    void ComputeControlSpace();

    ///@}
    ///@name Debug
    ///@{

    /// Print an actuator's state to an ostream.
    friend std::ostream& operator<<(std::ostream&, const Actuator&);

    ///@}
};

#endif
