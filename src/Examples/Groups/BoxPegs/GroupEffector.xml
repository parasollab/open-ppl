<?xml version='1.0' encoding='UTF-8'?>
<MotionPlanning warnings="true" warningsAsErrors="true" print="false">

  <!-- Here we specify input files, such as environment and query. -->
  <Problem>

    <Environment filename="box.env" positionRes=".01" orientationRes=".01"/>

    <Robot label="0">
      <MultiBody type="active">
        <Base filename="0.obj" color="0 1 0 1" type="volumetric" movement="rotational"/>
      </MultiBody>
    </Robot>
    <Robot label="1">
      <MultiBody type="active">
        <Base filename="1.obj" color="0 1 0 1" type="volumetric" movement="rotational"/>
      </MultiBody>
    </Robot>
    <Robot label="2">
      <MultiBody type="active">
        <Base filename="2.obj" color="0 1 0 1" type="volumetric" movement="rotational"/>
      </MultiBody>
    </Robot>
    <Robot label="3">
      <MultiBody type="active">
        <Base filename="3.obj" color="0 1 0 1" type="volumetric" movement="rotational"/>
      </MultiBody>
    </Robot>
    <Robot label="4">
      <MultiBody type="active">
        <Base filename="4.obj" color="0 1 0 1" type="volumetric" movement="rotational"/>
      </MultiBody>
    </Robot>
    <Robot label="5">
      <MultiBody type="active">
        <Base filename="5.obj" color="0 1 0 1" type="volumetric" movement="rotational"/>
      </MultiBody>
    </Robot>


    <!-- Define the end effector. Labels will be how the DSP strategy locates it. -->
    <Robot label="effector">
        <MultiBody filename="simple-effector.robot"/>
<!--  Note that the BBox center to contact point is the orientation used right now. -->
<!--         <Effector bodyIndex="0" contactPoint="0.0 0.0 -0.25"/> -->
        <Effector bodyIndex="0" contactPoint="0.0 0.0 0.05"/>
    </Robot>

<!-- Define the manipulator. Labels will be how the DSP strategy locates it. -->
    <Robot label="manipulator">
        <MultiBody filename="simple-manipulator.robot"/>
    </Robot>



    <RobotGroup label="robotGroup" robotLabels="0 1 2 3 4 5"/>

    <RobotGroup label="effectorGroup"
                robotLabels="0 1 2 3 4 5 effector"/>

    <RobotGroup label="manipulatorGroup"
                robotLabels="0 1 2 3 4 5 manipulator"/>



    <GroupTask label="groupTask" group="robotGroup"
               endEffectorGroupLabel="effectorGroup"
               manipulatorGroupLabel="manipulatorGroup">
      <Task label="task0" robot="0">
        <StartConstraints> <CSpaceConstraint point="-0.009666 0.4723035 0.476017 0 0 0"/> </StartConstraints>
      </Task>
      <Task label="task1" robot="1">
        <StartConstraints> <CSpaceConstraint point="-0.499666 0.472304 0.476017 0 0 0"/> </StartConstraints>
      </Task>
      <Task label="task2" robot="2">
        <StartConstraints> <CSpaceConstraint point="0.480334 0.472304 0.476017 0 0 0"/> </StartConstraints>
      </Task>
      <Task label="task3" robot="3">
        <StartConstraints> <CSpaceConstraint point="-0.009666 0.4723035 -0.523983 0 0 0"/> </StartConstraints>
      </Task>
      <Task label="task4" robot="4">
        <StartConstraints> <CSpaceConstraint point="0.480334 0.472304 -0.523983 0 0 0"/> </StartConstraints>
      </Task>
      <Task label="task5" robot="5">
        <StartConstraints> <CSpaceConstraint point="-0.499666 0.472304 -0.523983 0 0 0"/> </StartConstraints>
      </Task>
    </GroupTask>

  </Problem>
  <Library>
    <DistanceMetrics>
      <Euclidean label="euclidean"/>
    </DistanceMetrics>

    <ValidityCheckers>
      <GroupTwoRobotValidityChecker label="TwoBodyVC" method="PQP" debug="false"/>
      <CollisionDetection label="pqp" method="PQP" debug="false"/>

      <CollisionDetection label="pqpInterRobot" method="PQP_SOLID" interRobotCollision="true"
                          debug="true"/>

      <AlwaysTrueValidity label="alwaysTrue"/>
    </ValidityCheckers>

    <NeighborhoodFinders>
      <BruteForceNF label="BFNF" dmLabel="euclidean" unconnected="false" k="10"/>
      <BruteForceNF label="Nearest" dmLabel="euclidean" unconnected="false" k="1"/>
    </NeighborhoodFinders>

    <Samplers>
      <UniformRandomSampler label="UniformRandomFree" vcLabel="pqp"/>

      <MatingNormalSamplerGroup label="MatingNormalSampler" dist="8"
                                duplicateThreshold="0.05" debug="false"/>

      <MaskedProximitySamplerGroup label="MaskedProximitySampler"
          vcLabel="pqp" dmLabel="euclidean" maxDist="5" debug="false" />

      <MaskedProximitySamplerGroup label="MaskedProximitySamplerThanhLe"
          vcLabel="pqp" dmLabel="euclidean" maxDist="50" debug="false" />
    </Samplers>

    <LocalPlanners>
      <StraightLine label="sl" vcLabel="pqp"/>
      <RRTLocalPlanner label="rrtLP" rrtStrategyLabel="GoalBiasedRRT"/>
    </LocalPlanners>

    <Extenders>
      <BasicExtender label="BERO" debug="false" dmLabel="euclidean"
                     vcLabel="pqp" maxDist="100.0" minDist=".00005"/>
      <BasicExtender label="BEROInterRobot" debug="false" dmLabel="euclidean"
                     vcLabel="pqpInterRobot" maxDist="2" minDist=".05"/>
    </Extenders>

    <Metrics>
      <NumNodesMetric label="NumNodes"/>
      <NumEdgesMetric label="NumEdges"/>
      <DiameterMetric label="Diameter"/>
      <CCDistanceMetric label="CCDistance" dmLabel="euclidean"/>
      <TimeMetric label="TimeInSec"/>
    </Metrics>

    <MapEvaluators>
      <RRTQuery label="RRTQuery" goalDist="0" vcLabel="pqpInterRobot"
                nfLabel="Nearest" exLabel="BEROInterRobot" debug="false"/>

      <StrategyStateEvaluator label="stateEval"/>

<!-- Note: 200 is the number specified in Thanh Le's paper for Max Tree Size -->
      <ConditionalEvaluator label="NodeEval" metric_method="NumNodes"
                            value="200" operator=">="/>

      <MinimumClearanceEvaluator label="MinClearanceEval" vcLabel="pqp"
                         minDist="4" debug="false"/>

      <TimeEvaluator label="TimeEvalRRT" timeout="10"/>
      <TimeEvaluator label="TimeEvalDisassembly" timeout="6000"/>

      <TimeEvaluator label="TimeEvalThanhLeRRT" timeout="0.5"/>

      <ConditionalEvaluator label="NodeEvalRRTLP" metric_method="NumNodes"
                            value="200" operator=">="/>

      <ComposeEvaluator label="RRTEval" operator="or" debug="false">
        <Evaluator label="MinClearanceEval"/>
        <Evaluator label="TimeEvalRRT"/>
      </ComposeEvaluator>

      <ComposeEvaluator label="RRTNodesEval" operator="or" debug="false">
        <Evaluator label="MinClearanceEval"/>
        <Evaluator label="NodeEval"/>
        <Evaluator label="TimeEvalThanhLeRRT"/>
      </ComposeEvaluator>

      <ComposeEvaluator label="ComposeDisassembly" operator="or" debug="false">
        <Evaluator label="stateEval"/>
        <Evaluator label="TimeEvalDisassembly"/>
      </ComposeEvaluator>

      <ComposeEvaluator label="RRTQueryNodeLimit" operator="or" debug="false">
        <Evaluator label="RRTQuery"/>
        <Evaluator label="NodeEvalRRTLP"/>
      </ComposeEvaluator>
    </MapEvaluators>

    <MPStrategies>
      <DisassemblyPreemptiveDFSManipulator label="DisassemblyPreemptiveDFSManipulator"
        debug="true" numContactCandidates="1000000"
        vcLabel="pqp" singleVcLabel="TwoBodyVC"
        lpLabel="sl" exLabel="BERO" dmLabel="euclidean"
        contactDist="0.000001" neighborDist="1"
        printFullPath="true"
        skipPlacementMotionAfterRemoval="false"
        effectorPlacementLP="rrtLP"
        keepBestRRTPathOnFailure="true"
        stateMELabel="stateEval"
        removePos="-30" subassemblyPos="30" subassemblyOffset="20"
        useParallelRemoval="false"
        rrtDMLabel="euclidean">
        <MatingSampler method="MatingNormalSampler" number="1" attempts="1"/>
        <RRTSampler method="MaskedProximitySampler" number="1" attempts="1"/>
        <Evaluator label="ComposeDisassembly"/>
        <ExpandRRTStrategy method="BasicDisassemblyRRT"/>
      </DisassemblyPreemptiveDFSManipulator>

      <DisassemblyRRTStrategy label="BasicDisassemblyRRT" debug="false"
        nfLabel="Nearest" vcLabel="pqp"
        gtype="UNDIRECTED_TREE" samplerLabel="MaskedProximitySampler"
        extenderLabel="BERO"
        successfulCheckME="MinClearanceEval">
<!--  NOTE: the vc from the non-TimeEval of the two evaluators should match up
            with the disassembly strategy's vc label (should be pqp)
            Also, using an evalutaor with "query" in the label won't work. -->
        <Evaluator label="RRTEval"/>
      </DisassemblyRRTStrategy>


      <BasicRRTStrategy label="GoalBiasedRRT"
        numRoots="1" m="1" growthFocus="0.9" dmLabel="euclidean"
        nfLabel="Nearest" vcLabel="pqpInterRobot" connectorLabel="Closest"
        gtype="UNDIRECTED_TREE" writeAllOutputs="false"
        debug="true"
        growGoals="false" extenderLabel="BEROInterRobot" samplerLabel="UniformRandomFree">
<!--         <Evaluator label="RRTQuery"/> -->
        <Evaluator label="RRTQueryNodeLimit"/>
      </BasicRRTStrategy>

    </MPStrategies>

    <Solver mpStrategyLabel="DisassemblyPreemptiveDFSManipulator" seed="456741357"
       baseFilename="preemptiveDFS" vizmoDebug="true"/>

  </Library>

</MotionPlanning>
