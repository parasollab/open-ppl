#ifndef WORKSPACE_DECOMPOSITION_H
#define WORKSPACE_DECOMPOSITION_H

#include <vector>

#include <containers/sequential/graph/graph.h>
#include "Vector.h"

#include "WorkspacePortal.h"
#include "WorkspaceRegion.h"
#include "Utilities/PMPLExceptions.h"

////////////////////////////////////////////////////////////////////////////////
/// A region-decomposition representation of the workspace.
///
/// The decomposition regions are represented by WorkspaceRegion, while
/// connections between them are described by WorkspacePortal. Once the
/// decomposition has been constructed, it cannot be changed.
///
/// Currently it is only possible to add tetrahedral regions.
////////////////////////////////////////////////////////////////////////////////
class WorkspaceDecomposition : public stapl::sequential::graph<stapl::DIRECTED,
                                        stapl::NONMULTIEDGES, WorkspaceRegion,
                                        WorkspacePortal>{

  public:

    ///\name Local Types
    ///@{

    typedef stapl::sequential::graph<stapl::DIRECTED, stapl::NONMULTIEDGES,
        WorkspaceRegion, WorkspacePortal> RegionGraph;

    typedef typename RegionGraph::vertex_iterator         iterator;
    typedef typename RegionGraph::const_vertex_iterator   const_iterator;

    typedef typename RegionGraph::edge_iterator           edge_iterator;
    typedef typename RegionGraph::const_edge_iterator     const_edge_iterator;

    typedef typename RegionGraph::adj_edge_iterator       adj_edge_iterator;
    typedef typename RegionGraph::const_adj_edge_iterator const_adj_edge_iterator;

    typedef typename RegionGraph::vertex_descriptor       vertex_descriptor;
    typedef typename RegionGraph::edge_descriptor         edge_descriptor;

    typedef stapl::sequential::graph<stapl::DIRECTED, stapl::NONMULTIEDGES,
        Vector3d, double> DualGraph;

    ///@}
    ///@name Point Accessors
    ///@{

    const size_t GetNumPoints() const {return m_points.size();}

    const Point3d& GetPoint(const size_t _i) const {return m_points[_i];}
    const vector<Point3d>& GetPoints() const {return m_points;}

    ///@}
    ///@name Region Accessors
    ///@{

    const size_t GetNumRegions() const {return get_num_vertices();}

    const WorkspaceRegion& GetRegion(const size_t _i) const {
      return find_vertex(_i)->property();
    }

    ///@}
    ///@name Portal Accessors
    ///@{

    const WorkspacePortal& GetPortal(const size_t _i1, const size_t _i2) const;

    ///@}
    ///@name Dual Graph Accessors
    ///@{

    const DualGraph& GetDualGraph() const {return m_dual;}

    ///@}
    ///@name Modifiers
    ///@{

    ////////////////////////////////////////////////////////////////////////////
    /// @brief Add a point to the decomposition. This will be either a point on
    ///        a workspace obstacle or a point in the freespace generated by the
    ///        decomposition algorithm.
    /// @param[in] _p The point to add.
    void AddPoint(const Point3d& _p) throw(PMPLException);

    ////////////////////////////////////////////////////////////////////////////
    /// @brief Add a tetrahedral region to the decomposition.
    /// @param[in] _pts A set of four point indexes, representing the vertices
    ///                 of the tetrahedron.
    void AddTetrahedralRegion(const int _pts[4]) throw(PMPLException);

    ////////////////////////////////////////////////////////////////////////////
    /// @brief Add a portal between two regions.
    /// @param _r1 The first region.
    /// @param _r2 The second region.
    void AddPortal(const size_t _r1, const size_t _r2) throw(PMPLException);

    ////////////////////////////////////////////////////////////////////////////
    /// @brief Finalize this, thereby triggering exceptions upon further
    ///        attempts to modify the decomposition. This ensures that the dual
    ///        graph is accurate, and that no functions added later on try to
    ///        modify the points (which are indexed by the WorkspaceRegions).
    void Finalize();

    ///@}

  private:

    ///@name Helpers
    ///@{

    ////////////////////////////////////////////////////////////////////////////
    /// @brief Assert that the decomposition is not yet finalized, throwing an
    ///        exception if it is.
    void AssertMutable() const throw(PMPLException);

    ////////////////////////////////////////////////////////////////////////////
    /// @brief Compute the dual of the region graph.
    void ComputeDualGraph();

    ///@}
    ///@name Internal State
    ///@{

    vector<Point3d> m_points; ///< The points used in the decomposition.
    DualGraph m_dual;         ///< The dual-graph of the decomposition.

    bool m_finalized{false};  ///< Is the decomposition finalized?

    ///@}
};

#endif
