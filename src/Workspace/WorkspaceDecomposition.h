#ifndef WORKSPACE_DECOMPOSITION_H
#define WORKSPACE_DECOMPOSITION_H

#include <vector>

#include <containers/sequential/graph/graph.h>
#include "Vector.h"

#include "WorkspacePortal.h"
#include "WorkspaceRegion.h"
#include "Utilities/PMPLExceptions.h"

////////////////////////////////////////////////////////////////////////////////
/// A region-decomposition representation of the workspace.
///
/// The decomposition regions are represented by WorkspaceRegion, while
/// connections between them are described by WorkspacePortal. Once the
/// decomposition has been constructed, it cannot be changed.
///
/// Currently it is only possible to add tetrahedral regions.
////////////////////////////////////////////////////////////////////////////////
class WorkspaceDecomposition : public stapl::sequential::graph<stapl::DIRECTED,
                                        stapl::NONMULTIEDGES, WorkspaceRegion,
                                        WorkspacePortal>{

  public:

    ///@name Local Types
    ///@{

    typedef stapl::sequential::graph<stapl::DIRECTED, stapl::NONMULTIEDGES,
        WorkspaceRegion, WorkspacePortal> RegionGraph;

    typedef typename RegionGraph::vertex_iterator         iterator;
    typedef typename RegionGraph::const_vertex_iterator   const_iterator;

    typedef typename RegionGraph::edge_iterator           edge_iterator;
    typedef typename RegionGraph::const_edge_iterator     const_edge_iterator;

    typedef typename RegionGraph::adj_edge_iterator       adj_edge_iterator;
    typedef typename RegionGraph::const_adj_edge_iterator const_adj_edge_iterator;

    typedef typename RegionGraph::vertex_descriptor       vertex_descriptor;
    typedef typename RegionGraph::edge_descriptor         edge_descriptor;

    /// Terminology blunder: this isn't really a dual graph. It is a 1-reduction
    /// of the region graph instead. Each region is represented as a point, and
    /// each portal is represented as a euclidean straight-line distance between
    /// vertices.
    typedef stapl::sequential::graph<stapl::DIRECTED, stapl::NONMULTIEDGES,
        Vector3d, double> DualGraph;

    ///@}
    ///@name Construction
    ///@{

    WorkspaceDecomposition();

    WorkspaceDecomposition(const WorkspaceDecomposition&);
    WorkspaceDecomposition(WorkspaceDecomposition&&);

    virtual ~WorkspaceDecomposition();

    ///@}
    ///@name Assignment
    ///@{

    WorkspaceDecomposition& operator=(const WorkspaceDecomposition&);
    WorkspaceDecomposition& operator=(WorkspaceDecomposition&&);

    ///@}
    ///@name Point Accessors
    ///@{

    const size_t GetNumPoints() const noexcept;

    const Point3d& GetPoint(const size_t _i) const noexcept;

    const std::vector<Point3d>& GetPoints() const noexcept;

    ///@}
    ///@name Region Accessors
    ///@{

    const size_t GetNumRegions() const noexcept;

    const WorkspaceRegion& GetRegion(const size_t _i) const noexcept;

    const vertex_descriptor GetDescriptor(const WorkspaceRegion& _region) const
        noexcept;

    ///@}
    ///@name Portal Accessors
    ///@{

    const WorkspacePortal& GetPortal(const size_t _i1, const size_t _i2) const
        noexcept;

    ///@}
    ///@name Dual Graph Accessors
    ///@{

    DualGraph& GetDualGraph() noexcept;
    const DualGraph& GetDualGraph() const noexcept;

    ///@}
    ///@name Modifiers
    ///@{

    /// Add a point to the decomposition. This will be either a point on a
    /// workspace obstacle or a point in the freespace generated by the
    /// decomposition algorithm.
    /// @param _p The point to add.
    void AddPoint(const Point3d& _p);

    /// Add a tetrahedral region to the decomposition.
    /// @param _pts A set of four point indexes, representing the vertices
    ///             of the tetrahedron.
    void AddTetrahedralRegion(const int _pts[4]);

    /// Add a portal between two regions.
    /// @param _r1 The first region.
    /// @param _r2 The second region.
    void AddPortal(const size_t _r1, const size_t _r2);

    /// Finalize this, thereby triggering exceptions upon further attempts to
    /// modify the decomposition. This ensures that the dual graph is accurate,
    /// and that no functions added later on try to modify the points (which are
    /// indexed by the WorkspaceRegions).
    void Finalize();

    ///@}
    ///@name I/O
    ///@{

    /// Write the decomposition graph to an output stream.
    void Print(std::ostream& _os) const;

    /// Write an OBJ file of the decomposition regions to an output stream. The
    /// OBJ will include all internal facets. This is primarily for validating
    /// that a decomposition gave the expected result.
    void WriteObj(const std::string& _filename) const;

    ///@}
    ///@name Path Finding
    ///@{

    /// Find a path between two regions.
    /// @param _source The source region.
    /// @param _target The target region.
    std::vector<size_t> FindPath(const size_t _source, const size_t _target)
        const;
    /// @overload
    std::vector<size_t> FindPath(const WorkspaceRegion* const _source,
        const WorkspaceRegion* const _target) const;

    /// Find a neighborhood surrounding a set of regions.
    /// @param _roots The region descriptors to search from.
    /// @param _threshold The max distance from source, through midpoints, for
    ///                   other regions in the neighborhood.
    /// @return The descriptors within this neighborhood.
    std::vector<size_t> FindNeighborhood(const std::vector<size_t>& _roots,
        const double _threshold) const;

    ///@}

  private:

    ///@name Helpers
    ///@{

    /// Assert that the decomposition is not yet finalized, throwing an exception
    /// if it is.
    void AssertMutable() const;

    /// Compute the dual of the region graph.
    void ComputeDualGraph();

    /// Set the decomposition pointers for all regions and portals, which is
    /// needed when copying/moving this object.
    void UpdateDecompositionPointers();

    ///@}
    ///@name Internal State
    ///@{

    std::vector<Point3d> m_points; ///< The points used in the decomposition.
    DualGraph m_dual;              ///< The dual-graph of the decomposition.

    bool m_finalized{false};       ///< Is the decomposition finalized?

    ///@}
};

#endif
