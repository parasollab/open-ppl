<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Parasol Planning Library (PPL): Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="parasol_logo_transparent_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Parasol Planning Library (PPL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>Module <a class="el" href="classMapEvaluatorMethod.html#amgrp97b2d5b2eeac0e45920bcb515a011c8a">Active Robots</a>  </dt>
<dd><a class="anchor" id="_todo000037"></a>This is an artifact of developing robot groups. It should be replaced by using a proper subgroup where each robot within is active.  </dd>
<dt>Global <a class="el" href="classActuator.html#a88e1e1d1b06f436d16b16da4b47be3e2">Actuator::ComputeOutput</a>  (const <a class="el" href="structControl.html#ae41582bcc718e53fb154bef2e65e4d13">Control::Signal</a> &amp;_s) const</dt>
<dd><a class="anchor" id="_todo000090"></a>Generalize this so that the robot's starting point can be taken into account. Currently we assume that the generated force is independent of starting state.  </dd>
<dt>Global <a class="el" href="TetGenDecomposition_8cpp.html#a1075e70c59d01354cd32019c0a7a63a6">AddHoles</a>  (tetgenio *const _freeModel, const NefPolyhedron &amp;_freespace, const <a class="el" href="classEnvironment.html">Environment</a> *const _env, const bool _debug)</dt>
<dd><a class="anchor" id="_todo000055"></a>There seems to be an intermittent problem with adding holes for obstacles that touch the environment boundary. Sometimes it causes bad decompositions where the free space gets eaten away, and sometimes not. Not adding the hole sometimes causes tetgen to not remove the tetras within the obstacle. We need to characterize the cases where it fails and where it works.  </dd>
<dt>Global <a class="el" href="classBasicExtender.html#a7ffbb121e5436253ece67508b30a39a1">BasicExtender::Expand</a>  (const <a class="el" href="classCfg.html">Cfg</a> &amp;_start, const <a class="el" href="classCfg.html">Cfg</a> &amp;_end, <a class="el" href="classCfg.html">Cfg</a> &amp;_newCfg, double _delta, <a class="el" href="structLPOutput.html">LPOutput</a> &amp;_lp, <a class="el" href="structCDInfo.html">CDInfo</a> &amp;_cdInfo, double _posRes, double _oriRes)</dt>
<dd><a class="anchor" id="_todo000025"></a>No, we don't <em>have</em> to set _newCfg to _end, and it would be better if we didn't use this assumption. We are doing this so that we can use extenders as local planners in multi-tree RRT methods. To fix and remove the assumption, we need to homogenize our extenders and local planners into a single class with methods for both uses (i.e. 'Extend' and 'LocalPlan').  </dd>
<dt>Global <a class="el" href="classBasicPRM.html#a770e91bb07b8bbed5ec736ac44acb1f6">BasicPRM::Initialize</a>  () override</dt>
<dd><a class="anchor" id="_todo000041"></a>Move input map parsing to the MPSolution somehow?  </dd>
<dt>Global <a class="el" href="classBasicRRTStrategy.html#a0912f9aa21b53a8ccdd36173f01edd82">BasicRRTStrategy::SelectDispersedTarget</a>  (const VID _v)</dt>
<dd><a class="anchor" id="_todo000042"></a>This functionality can probably be moved into a dispersed extender, which we could call several times here.  </dd>
<dt>Class <a class="el" href="classCCTracker.html">CCTracker&lt; RoadmapType &gt;</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000094"></a>Add support for non-tree directed graphs. We need to use predecessor information to do this, which we now have in the roadmap graph. </p>
<p class="enddd">The stat class tracking adds a lot of complication. Remove it once we're sure the performance is fast enough to forgo tracking. </p>
</dd>
<dt>Class <a class="el" href="structCDInfo.html">CDInfo</a>  </dt>
<dd><a class="anchor" id="_todo000066"></a>Generalize this object to store collisions with obstacles, boundaries, and other robots in a uniform way. It should contain a vector of 'Collision' structures which describe the object type, indexes, and distance for each detected collision. </dd>
<dt>Global <a class="el" href="classCfg.html#aa890f415f3e4fb58aa62986677bbd511">Cfg::operator&lt;</a>  (const <a class="el" href="classCfg.html">Cfg</a> &amp;_cfg) const</dt>
<dd><a class="anchor" id="_todo000001"></a>The function currently seems to check each dof in order, returning T/F immediately unless exactly equal; is this intended?  </dd>
<dt>Global <a class="el" href="classChain.html#a5fe241c0868b96b0bd7f9bbc27b7a8f3">Chain::Decompose</a>  (const <a class="el" href="classMultiBody.html">MultiBody</a> *const _mb)</dt>
<dd><a class="anchor" id="_todo000009"></a>Expand to support joints with more than one forward or backward connection. For now we only support chain robots.  </dd>
<dt>Class <a class="el" href="classCollisionDetectionValidity.html">CollisionDetectionValidity</a>  </dt>
<dd><a class="anchor" id="_todo000074"></a>Remove the 'GetCDMethod' function after re-implementing <a class="el" href="classObstacleClearanceValidity.html">ObstacleClearanceValidity</a> as a subtype of <a class="el" href="classCollisionDetectionValidity.html">CollisionDetectionValidity</a>. </dd>
<dt>Global <a class="el" href="classCollisionDetectionValidity.html#aa41895a328f8cfb1eff4f6e4f2638e9c">CollisionDetectionValidity::IsInBoundaryCollision</a>  (<a class="el" href="structCDInfo.html">CDInfo</a> &amp;_cdInfo, const <a class="el" href="classCfg.html">Cfg</a> &amp;_cfg)</dt>
<dd><a class="anchor" id="_todo000072"></a>This also doesn't work, we can't distinguish between no collision, self collision, and boundary collision since we use -1 for all three.  </dd>
<dt>Global <a class="el" href="classCollisionDetectionValidity.html#a1d8b1840fa98a31ad58aa544cda56cf6">CollisionDetectionValidity::IsInInterRobotCollision</a>  (<a class="el" href="structCDInfo.html">CDInfo</a> &amp;_cdInfo, <a class="el" href="classRobot.html">Robot</a> *const _robot, const std::vector&lt; Robot * &gt; &amp;_robots, const std::string &amp;_caller)</dt>
<dd><a class="anchor" id="_todo000073"></a>Arg, more ambiguous data. See above.  </dd>
<dt>Global <a class="el" href="classCollisionDetectionValidity.html#aae8a2dd6c70b0460208b66ef8bfdb043">CollisionDetectionValidity::IsInSelfCollision</a>  (<a class="el" href="structCDInfo.html">CDInfo</a> &amp;_cdInfo, const <a class="el" href="classMultiBody.html">MultiBody</a> *const _multibody, const std::string &amp;_caller)</dt>
<dd><a class="anchor" id="_todo000071"></a>-1 is the default value here, so this doesn't really work. We need to expand our <a class="el" href="structCDInfo.html">CDInfo</a> object to handle this properly.  </dd>
<dt>Global <a class="el" href="classCollisionDetectionValidity.html#a40bbca5b1335fdd9e37751990805ea1e">CollisionDetectionValidity::IsInsideObstacle</a>  (const Point3d &amp;_p) override</dt>
<dd><a class="anchor" id="_todo000069"></a>Implement a bounding box check (per multibody and body) before calling m_cdMethod.  </dd>
<dt>Global <a class="el" href="classCollisionDetectionValidity.html#ab51c4fe24f9ef19cfcc058e09ccdb77e">CollisionDetectionValidity::IsInsideObstacle</a>  (const Point3d &amp;_p, std::vector&lt; size_t &gt; *_obstIdxs)</dt>
<dd><a class="anchor" id="_todo000070"></a>Implement a bounding box check (per multibody and body) before calling m_cdMethod.  </dd>
<dt>Global <a class="el" href="classCompositeState.html#a3926e337e53d3115866d43a8ec98f16c">CompositeState&lt; GraphType &gt;::GetRobot</a>  (const size_t _index) const</dt>
<dd><a class="anchor" id="_todo000002"></a>Remove this after we are very sure things are working.  </dd>
<dt>Global <a class="el" href="ReachableVolumes_8cpp.html#ae896ff26687bd0f7887e40075eb908bd">ComputeReachableDistanceOfSingleLink</a>  (const size_t _dimension, const <a class="el" href="classConnection.html">Connection</a> *_joint, const <a class="el" href="classConnection.html">Connection</a> *_parent, const <a class="el" href="classChain.html">Chain</a> *_chain)</dt>
<dd><a class="anchor" id="_todo000008"></a>We can probably support some non-actuated joints here, but need to verify with the theory.  </dd>
<dt>Global <a class="el" href="classCSpaceConstraint.html#acd331d725f90ff0838c92fb172254cf5">CSpaceConstraint::CSpaceConstraint</a>  (<a class="el" href="classRobot.html">Robot</a> *const _r, <a class="el" href="classXMLNode.html">XMLNode</a> &amp;_node, <a class="el" href="classEnvironment.html">Environment</a> *_env=nullptr)</dt>
<dd><a class="anchor" id="_todo000076"></a>Verify that this works with constraints of lower dimension than the robot's cspace (for partial constraint), or decide that we will not support this and throw an error if requested.  </dd>
<dt>Global <a class="el" href="classDistanceMetricMethod.html#ad64b345595c31703d3986e6119d6e1ca">DistanceMetricMethod::EdgeWeight</a>  (const RoadmapType *const _r, const typename <a class="el" href="classGenericStateGraph.html#a5bb9f6095c2345537494a80c3dacae01">RoadmapType::CEI</a> &amp;_edge) noexcept</dt>
<dd><a class="anchor" id="_todo000013"></a>We need to make this work for group roadmaps. Probably it needs to take the roadmap as a templated parameter and not be virtual (there is really only one way to do this).  </dd>
<dt>Global <a class="el" href="classDistanceMetricMethod.html#a43c4f57f3928cc72e9bbc3705e48a444">DistanceMetricMethod::ScaleCfg</a>  (double _length, <a class="el" href="classCfg.html">Cfg</a> &amp;_c, const <a class="el" href="classCfg.html">Cfg</a> &amp;_o)</dt>
<dd><a class="anchor" id="_todo000012"></a>This is a very expensive way to scale a configuration. We should probably remove it and require derived classes to implement a more efficient function (this is the best we can do for a base class that does not know anything about the properties of the metric space).  </dd>
<dt>Global <a class="el" href="classEnvironment.html#ad45e7dd3f3950e73c1159efe4a5d4a32">Environment::ComputeResolution</a>  (const std::vector&lt; std::unique_ptr&lt; Robot &gt;&gt; &amp;_robots)</dt>
<dd><a class="anchor" id="_todo000080"></a>Add an automatic computation of the orientation resolution here. This should be done so that rotating the robot base by one orientation resolution makes a point on the bounding sphere move by one position resolution. If possible we should also separate the resolutions for joint angles and base orientations since this gets really, really small with manipulators having several links (probably we'll need to manage this in the local planner to make maximum use of the available resolution).  </dd>
<dt>Global <a class="el" href="classEnvironment.html#a38a8da8d52c6dae39f19bc81e42fdc6d">Environment::Read</a>  (std::string _filename)</dt>
<dd><a class="anchor" id="_todo000079"></a>Add support for dynamic obstacles  </dd>
<dt>Global <a class="el" href="classEnvironment.html#a3b16963b14a61946ad47894213048ca4">Environment::ReadXML</a>  (<a class="el" href="classXMLNode.html">XMLNode</a> &amp;_node)</dt>
<dd><a class="anchor" id="_todo000078"></a>Add support for dynamic obstacles  </dd>
<dt>Class <a class="el" href="classExtenderMethod.html">ExtenderMethod</a>  </dt>
<dd><a class="anchor" id="_todo000026"></a>Local planners and Extenders represent the same concepts and should be merged into a single class with both an Extend and LocalPlan function. This will help simplify several other objects within PMPL as well, such as bi-directional RRT. </dd>
<dt>Global <a class="el" href="classGMSPolyhedron.html#a05ce9bec1b5aeabf1b07d30c4ef296d7">GMSPolyhedron::COMAdjust</a>  </dt>
<dd><a class="anchor" id="_todo000010"></a>This has been a major source of bugs for a long time and should be removed entirely. All polyhedrons should be bounding-box centered without exception. </dd>
<dt>Class <a class="el" href="classGridOverlay.html">GridOverlay</a>  </dt>
<dd><a class="anchor" id="_todo000099"></a>Generalize to support 2d grids as well as 3d. </dd>
<dt>Global <a class="el" href="classGridOverlay.html#a5b009d33707877f4e4e716819d9f8ffe">GridOverlay::LocateCells</a>  (const <a class="el" href="classGMSPolyhedron.html">GMSPolyhedron</a> &amp;_polyhedron, const mathtool::Transformation &amp;_transformation={}, const CellSet _type=<a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400aaf4bb376939e77df0e7c2332b837a866">CellSet::Closure</a>) const</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000098"></a>Can make both versions more efficient by avoiding re-building the _polyhedron's BBX each time. Add min/max pts and transform them with the poly, use here. </p>
<p class="enddd"><a class="anchor" id="_todo000097"></a>Can make the !_interior version more efficient by computing bbx cells for each facet.  </p>
</dd>
<dt>Global <a class="el" href="classGroupCfg.html#a16e8ee7a24aeb96b50b96c275a1202b1">GroupCfg&lt; GraphType &gt;::ApplyTransformationForRobots</a>  (const Formation &amp;_robotList, const mathtool::Transformation &amp;_transform, const mathtool::Transformation &amp;_relativeTransform=mathtool::Transformation())</dt>
<dd><a class="anchor" id="_todo000004"></a>Generalize this to handle robots with more than one body.  </dd>
<dt>Global <a class="el" href="classGroupCfg.html#ad35e75989a0c639064173b0a60e3f45c">GroupCfg&lt; GraphType &gt;::RotateFormationAboutLeader</a>  (const Formation &amp;_robotList, const mathtool::Orientation &amp;_rotation, const bool _debug=false)</dt>
<dd><a class="anchor" id="_todo000003"></a>We can probably compute this without having to configure the models (which cost a lot of transformations).  </dd>
<dt>Class <a class="el" href="structGroupLPOutput.html">GroupLPOutput</a>  </dt>
<dd><a class="anchor" id="_todo000029"></a>Destroy this object and have LPs/Extenders work directly with a <a class="el" href="classGroupLocalPlan.html">GroupLocalPlan</a>. </dd>
<dt>Global <a class="el" href="structGroupLPOutput.html#a23bc8c8657bd2fbd0be26f40af8e1dcf">GroupLPOutput::SetIndividualEdges</a>  (const std::vector&lt; size_t &gt; &amp;_formation)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000028"></a>This is not a correct edge for each individual robot - they will not all have the same weight. This needs to be tracked separately. </p>
<p class="enddd"><a class="anchor" id="_todo000027"></a>We need to preserve the intermediates.  </p>
</dd>
<dt>Global <a class="el" href="classGroupPath.html#af4672f7a6f1636b786ded3df9d4571a7">GroupPath::Length</a>  () const</dt>
<dd><a class="anchor" id="_todo000005"></a>This will be an error if we allow self-edges.  </dd>
<dt>Global <a class="el" href="classGroupPath.html#a03deeb29ae92572d77851e98ddb50964">GroupPath::TimeSteps</a>  () const</dt>
<dd><a class="anchor" id="_todo000006"></a>This will be an error if we allow self-edges.  </dd>
<dt>Class <a class="el" href="classGroupPRM.html">GroupPRM</a>  </dt>
<dd><a class="anchor" id="_todo000044"></a>Create option for decoupled planning. </dd>
<dt>Global <a class="el" href="classGroupPRM.html#af41e0ca87f1769567be8c43cd2242074">GroupPRM::Connect</a>  (const std::vector&lt; VID &gt; &amp;_vids)</dt>
<dd><a class="anchor" id="_todo000043"></a>Setup CC tracker for groups to fix this.  </dd>
<dt>Class <a class="el" href="classGroupQuery.html">GroupQuery</a>  </dt>
<dd><a class="anchor" id="_todo000036"></a>There is a lot of copy-pasted code from <a class="el" href="classQueryMethod.html">QueryMethod</a> because that method calls several other objects which are not ready for groups yet. We should be able to merge these two after a bit more flush-out of the group support. I have marked it final to remind us that we should not extend this as it will be merged. </dd>
<dt>Class <a class="el" href="classGroupStrategyMethod.html">GroupStrategyMethod</a>  </dt>
<dd><a class="anchor" id="_todo000049"></a>Incorporate path constraints when generating the start and goal. </dd>
<dt>Global <a class="el" href="classGroupStrategyMethod.html#a714e5972e1d6164b3c4670b1835680ca">GroupStrategyMethod::GenerateGoals</a>  (const std::string &amp;_samplerLabel) override</dt>
<dd><a class="anchor" id="_todo000046"></a>For now we will only support one task per robot. Generalize this to support more task arrangements.  </dd>
<dt>Global <a class="el" href="classGroupStrategyMethod.html#a35218d0f25587ceb59eb6bcfa257f122">GroupStrategyMethod::GenerateStart</a>  (const std::string &amp;_samplerLabel) override</dt>
<dd><a class="anchor" id="_todo000045"></a>For now we will only support one task per robot. Generalize this to support more task arrangements.  </dd>
<dt>Global <a class="el" href="classGroupStrategyMethod.html#aaf0603460a00a7d6a0cc8c9c51097e87">GroupStrategyMethod::GetGoalBoundaryMaps</a>  () const noexcept</dt>
<dd><a class="anchor" id="_todo000048"></a>For now we will only support one task per robot. Generalize this to support more task arrangements.  </dd>
<dt>Global <a class="el" href="classGroupStrategyMethod.html#abc5ad1b02179b83c80e88756e0e1ed54">GroupStrategyMethod::GetStartBoundaryMap</a>  () const noexcept</dt>
<dd><a class="anchor" id="_todo000047"></a>For now we will only support one task per robot. Generalize this to support more task arrangements.  </dd>
<dt>Class <a class="el" href="classGroupTask.html">GroupTask</a>  </dt>
<dd><a class="anchor" id="_todo000083"></a>Move disassembly-specific items to a derived class specifically for disassembly tasks. </dd>
<dt>Global <a class="el" href="classGroupTask.html#abff999e0501332a545150334c429775a">GroupTask::GetEndEffectorRobot</a>  ()</dt>
<dd><a class="anchor" id="_todo000082"></a>This uses magic strings in the XML files, let's find a better way.  </dd>
<dt>Global <a class="el" href="classGroupTask.html#ab22b900e8593eaa8ededd0fa6e022d7d">GroupTask::GetManipulatorRobot</a>  ()</dt>
<dd><a class="anchor" id="_todo000081"></a>This uses magic strings in the XML files, let's find a better way.  </dd>
<dt>Global <a class="el" href="classGroupTask.html#a861ea5cd28575d44d476c10b72265448">GroupTask::GetStartConstraintCenter</a>  (GroupCfgType &amp;_center) const noexcept</dt>
<dd><a class="anchor" id="_todo000084"></a>This is a hack that was needed to move the disassembly work forward before we had flushed out the tasks/groups. To be removed at the earliest opportunity.  </dd>
<dt>Module <a class="el" href="classNeighborhoodFinderMethod.html#amgrpa0fd7182f4d2491c8c75f511addc3e01">Internal State</a>  </dt>
<dd><a class="anchor" id="_todo000062"></a>Remove m_k and m_radius - these don't apply to all NFs so it doesn't make sense to have them here. Fix design errors in SRT method which require this.  </dd>
<dt>Class <a class="el" href="classKdTreeNF.html">KdTreeNF</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000060"></a>We should be able to use a Search_traits_adaptor to avoid recopying the points and instead put VIDs into the kd tree. However my attempt to do that resulted in bogus runtime behavior within CGAL's Kd_tree::build (dimension is computed incorrectly resulting in a bad array size). Figure out how to finagle this so that we can avoid recopying Cfgs.</p>
<p class="enddd"><a class="anchor" id="_todo000061"></a>This is limited to euclidean distance at present, but it should be possible to use any minkowski or mahalonobis distance with the appropriate distance adapter. It can <em>not</em> support arbitrary distances despite the claims in CGAL's documentation because the implementation requires finding the nearest and furthest point to an AABB; this is not tractible unless the geometrically nearest/farthest points (i.e. measured with euclidean) are also the nearest points for our metric. </p>
</dd>
<dt>Class <a class="el" href="classLocalPlannerMethod.html">LocalPlannerMethod</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000030"></a>All local planners need to use a distance metric to set their edge weights properly; currently many of them are simply using the number of intermediate steps as a weight. </p>
<p class="enddd">Local planners and Extenders represent the same concepts and should be merged into a single class with both an Extend and LocalPlan function. This will help simplify several other objects within PMPL as well, such as bi-directional RRT. </p>
</dd>
<dt>Class <a class="el" href="structLPOutput.html">LPOutput</a>  </dt>
<dd><a class="anchor" id="_todo000031"></a>Destroy this object and have LPs/Extenders work directly with a LocalPlan object, which should replace the <a class="el" href="classDefaultWeight.html">DefaultWeight</a> class as our roadmap edge. </dd>
<dt>Global <a class="el" href="classLPSweptDistance.html#a4af95e9c7ccc43a673b32558997bda56">LPSweptDistance::Distance</a>  (const <a class="el" href="classCfg.html">Cfg</a> &amp;_c1, const <a class="el" href="classCfg.html">Cfg</a> &amp;_c2) override</dt>
<dd><a class="anchor" id="_todo000014"></a>Verify this, I believe m_path does include _c1 and _c2 for some lps. We need to make sure the usage is consistent across all of them.  </dd>
<dt>Global <a class="el" href="classMapEvaluatorMethod.html#a5cb6c6d857c17c7054234a88b510fc4d">MapEvaluatorMethod::m_activeRobots</a>  </dt>
<dd><a class="anchor" id="_todo000038"></a>This is an artifact of developing robot groups. It should be replaced by using a proper subgroup where each robot within is active.  </dd>
<dt>Class <a class="el" href="classMinkowskiDistance.html">MinkowskiDistance</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000017"></a>Move the normalization option up to the base class.</p>
<p class="interdd"><a class="anchor" id="_todo000016"></a>Remove m_r2, which isn't part of the Minkowski difference and doesn't have any valid use.</p>
<p class="enddd"><a class="anchor" id="_todo000018"></a>Separate the computation of orientation and joint distances. </p>
</dd>
<dt>Global <a class="el" href="classMinkowskiDistance.html#ac2e200d5de370a45d0f65501ec452284">MinkowskiDistance::ScaleCfg</a>  (double _length, <a class="el" href="classCfg.html">Cfg</a> &amp;_c, const <a class="el" href="classCfg.html">Cfg</a> &amp;_o) override</dt>
<dd><a class="anchor" id="_todo000015"></a>This implementation is very poor. Scaling should be a constant-time operation - complexity should not depend on the length of the input vector.  </dd>
<dt>Global <a class="el" href="classMPProblem.html#a1be220913145bd64ca65caba4d559ee3">MPProblem::ParseChild</a>  (<a class="el" href="classXMLNode.html">XMLNode</a> &amp;_node)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000086"></a>We currently assume that the environment is parsed first. Need to make sure this always happens regardless of the XML file ordering. </p>
<p class="enddd"><a class="anchor" id="_todo000087"></a>Add check that tasks have unique labels  </p>
</dd>
<dt>Global <a class="el" href="classMPProblem.html#a6c4b78d6682e889c9608b9c57597b9fa">MPProblem::Print</a>  (std::ostream &amp;_os) const</dt>
<dd><a class="anchor" id="_todo000085"></a>Print robot and task information.  </dd>
<dt>Class <a class="el" href="classMPSolutionType.html">MPSolutionType</a>  </dt>
<dd><a class="anchor" id="_todo000040"></a>Currently this object can represent a solution for each single robot and several robot group. It can almost support multiple of each - it just needs an interface for adding more robots/groups to the container. </dd>
<dt>Class <a class="el" href="classMPStrategyMethod.html">MPStrategyMethod</a>  </dt>
<dd><a class="anchor" id="_todo000051"></a>Incorporate path constraints when generating the start and goal. </dd>
<dt>Global <a class="el" href="classMPStrategyMethod.html#a81d856b963f876938d08385bd3217e79">MPStrategyMethod::ClearRoadmap</a>  ()</dt>
<dd><a class="anchor" id="_todo000050"></a>This uses the STAPL graph 'clear' function, which doesn't activate any roadmap hooks. Methods which use hooks may have stale data after clearing the map. To fix we'll need to replace with our own function in RoadmapGraph.  </dd>
<dt>Class <a class="el" href="classMPTask.html">MPTask</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000088"></a>We should remove the capability here and redefine it as a constraint (since the constraints should fully define the task). The fact that a capability is or is not required should generally be discerned from the problem, while a capability constraint would more likely represent a deliberate restriction that is not strictly required (perhaps to express an operational preference). We will also eventually encounter cases where multiple capabilities are required to satsify a task.</p>
<p class="enddd"><a class="anchor" id="_todo000089"></a>Support the use of path constraints in the library code, which currently doesn't care about this. </p>
</dd>
<dt>Global <a class="el" href="classNSphericalShell.html#a2f24f61884a226eb9d5b45bd73790dd2">NSphericalShell::Sample</a>  () const</dt>
<dd><a class="anchor" id="_todo000011"></a>This is likely close but not correct, need to verify.  </dd>
<dt>Class <a class="el" href="classObstacleBasedSampler.html">ObstacleBasedSampler</a>  </dt>
<dd><a class="anchor" id="_todo000063"></a>Implement GetCenterOfMass function in the ChooseCenterOfMass class </dd>
<dt>Class <a class="el" href="classObstacleClearanceValidity.html">ObstacleClearanceValidity</a>  </dt>
<dd><a class="anchor" id="_todo000075"></a>Re-implement this as a derived class of <a class="el" href="classCollisionDetectionValidity.html">CollisionDetectionValidity</a> and remove the 'GetCDMethod' function. </dd>
<dt>Global <a class="el" href="classPath.html#a119c6df2842412905c1eb5318a8a933f">Path::Length</a>  () const</dt>
<dd><a class="anchor" id="_todo000007"></a>This will be an error if we allow self-edges.  </dd>
<dt>Global <a class="el" href="classPQPSolid.html#abba8ef2f0c9413cbefc614d6e044b311">PQPSolid::IsInsideObstacle</a>  (const mathtool::Vector3d &amp;_point, const <a class="el" href="classGMSPolyhedron.html">GMSPolyhedron</a> &amp;_polyhedron, const mathtool::Transformation &amp;_transformation) override</dt>
<dd><a class="anchor" id="_todo000067"></a>This can still fail. I.e., what if we collide with two entering and one leaving triangle, as if we shot straight past the tip of a tetrahedron with the seem exactly aligned with the starting point? We need to check <em>all</em> colocated points, not just a pair. On detection of a scrape (colocated and different type) we need to erase all of the colocated collisions.  </dd>
<dt>Class <a class="el" href="classQueryMethod.html">QueryMethod</a>  </dt>
<dd><a class="anchor" id="_todo000039"></a>Implement A* by accepting a distance metric label for the heuristic function, and expanding the SSSP functions to accept a binary functor heuristic function. </dd>
<dt>Class <a class="el" href="classRapid.html">Rapid</a>  </dt>
<dd><a class="anchor" id="_todo000068"></a>There is no reason we can't support IsInsideObstacle with RAPID. This isn't really a part of <a class="el" href="classPQP.html">PQP</a> either - it's auxilliary code we created with a ray-shooting test. We can do the same thing here with an added 'RapidSolid' class, or by toggling the IsInsideObstacle check with a flag both here and in <a class="el" href="classPQP.html">PQP</a>. </dd>
<dt>Class <a class="el" href="classRMSDDistance.html">RMSDDistance</a>  </dt>
<dd><a class="anchor" id="_todo000019"></a>Properly document. This looks like a very complex way to assess RMS distance between body translations. </dd>
<dt>Class <a class="el" href="classRobot.html">Robot</a>  </dt>
<dd><a class="anchor" id="_todo000092"></a>Come up with a nice way to support both real and emulated hardware. </dd>
<dt>Global <a class="el" href="classRobot.html#a30265be650855e49ad729b91161873fa">Robot::InitializePlanningSpaces</a>  ()</dt>
<dd><a class="anchor" id="_todo000091"></a>Set up a way to specify velocity limits for each joint.  </dd>
<dt>Class <a class="el" href="classSamplerMethod.html">SamplerMethod</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000064"></a>The present implementation of Sample temporarily saves invalid configurations whether we will use them or not. Avoiding this extraneous retention will likely have good performance benefits in sampling-intensive applications such as proteins and manipulators where the success rate is very low.</p>
<p class="enddd"><a class="anchor" id="_todo000065"></a>The present layout of this class is confusing since the base method is actually generating uniform random samples which are filtered by the derived class. This does not work for many derived classes as evidenced by their overriding of Sample rather than Sampler: we should rework the design so that derived classes generate and filter their own samples. The base class can then implement its functions in terms of the generate and filter helpers. </p>
</dd>
<dt>Class <a class="el" href="classScaledEuclideanDistance.html">ScaledEuclideanDistance</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000021"></a>Replace with WeightedEuclidean, which full encompases this class and offers more functionality.</p>
<p class="enddd"><a class="anchor" id="_todo000020"></a>Separate the computation of orientation and joint distances. </p>
</dd>
<dt>Class <a class="el" href="structstd_1_1hash_3_01std_1_1pair_3_01T_00_01U_01_4_01_4.html">std::hash&lt; std::pair&lt; T, U &gt; &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000095"></a>Double-check that we get similar performance with differing types. </dd>
<dt>Global <a class="el" href="classStraightLine.html#a44aee36171e83af4e35f591158e75adb">StraightLine::IsConnected</a>  (const GroupCfgType &amp;_c1, const GroupCfgType &amp;_c2, GroupCfgType &amp;_col, <a class="el" href="structGroupLPOutput.html">GroupLPOutput</a> *_lpOutput, double _positionRes, double _orientationRes, bool _checkCollision=true, bool _savePath=false, const Formation &amp;_robotIndexes=<a class="el" href="classStraightLine.html#a41fb01ac26a6b4c2c3a98d958282a186">Formation()</a>) override</dt>
<dd><a class="anchor" id="_todo000032"></a>This can likely be optimized. For one, only one Configure call should be necessary here. Also a lot of the group Cfgs here could be made individual if using the leader, then using Configure on that.  </dd>
<dt>Global <a class="el" href="classStraightLine.html#acd6cd628888ac034eab17ef310a35126">StraightLine::IsConnectedEqualVelocities</a>  (const GroupCfgType &amp;_c1, const GroupCfgType &amp;_c2, GroupCfgType &amp;_col, <a class="el" href="structGroupLPOutput.html">GroupLPOutput</a> *_lpOutput, double _positionRes, double _orientationRes, bool _checkCollision, bool _savePath, const Formation &amp;_robotIndexes)</dt>
<dd><a class="anchor" id="_todo000033"></a>This can likely be optimized. For one, only one Configure call should be necessary here. Also a lot of the group Cfgs here could be made individual if using the leader, then using Configure on that.  </dd>
<dt>Global <a class="el" href="classStraightLine.html#a2fb015d86c62f81dc1674deef43fb411">StraightLine::IsConnectedSLBinary</a>  (const <a class="el" href="classCfg.html">Cfg</a> &amp;_c1, const <a class="el" href="classCfg.html">Cfg</a> &amp;_c2, <a class="el" href="classCfg.html">Cfg</a> &amp;_col, <a class="el" href="structLPOutput.html">LPOutput</a> *_lpOutput, int &amp;_cdCounter, double _positionRes, double _orientationRes, bool _checkCollision=true, bool _savePath=false)</dt>
<dd><a class="anchor" id="_todo000035"></a>Why are we running a local planner on an interaction edge? That shouldn't be necessary since we need neither intermediates nor CD information in that case?  </dd>
<dt>Global <a class="el" href="classStraightLine.html#a820e0847582cc0614e5c94efd372a5b1">StraightLine::IsConnectedSLSequential</a>  (const <a class="el" href="classCfg.html">Cfg</a> &amp;_c1, const <a class="el" href="classCfg.html">Cfg</a> &amp;_c2, <a class="el" href="classCfg.html">Cfg</a> &amp;_col, <a class="el" href="structLPOutput.html">LPOutput</a> *_lpOutput, int &amp;_cdCounter, double _positionRes, double _orientationRes, bool _checkCollision=true, bool _savePath=false)</dt>
<dd><a class="anchor" id="_todo000034"></a>Why are we running a local planner on an interaction edge? That shouldn't be necessary since we need neither intermediates nor CD information in that case?  </dd>
<dt>Global <a class="el" href="classSyclop.html#aacaae1f4131415231ece6989842510ca">Syclop::ComputeFreeVolumes</a>  ()</dt>
<dd><a class="anchor" id="_todo000052"></a>Remove dependence on magic XML values.  </dd>
<dt>Class <a class="el" href="classTogglePRMStrategy.html">TogglePRMStrategy</a>  </dt>
<dd><a class="anchor" id="_todo000053"></a>This can probably derive from <a class="el" href="classBasicPRM.html">BasicPRM</a> to reduce duplication of common code. </dd>
<dt>Global <a class="el" href="classTopologicalMap.html#ab391bedab79fc9a3a53e2768bcf3d2e6">TopologicalMap::ComputeApproximateMinimumInnerDistances</a>  (const <a class="el" href="classWorkspaceRegion.html">WorkspaceRegion</a> *const _source, const double _radius)</dt>
<dd><a class="anchor" id="_todo000058"></a>Refactor this and SSSP code to unify implementations. I think it should be feasible to make an adaptor class to give our grid (which represents an implicit graph) an API that is compatible with the STAPL (explicit) graph.  </dd>
<dt>Global <a class="el" href="classTopologicalMap.html#a20b5b8b27c116087e51332f3fde3fbf3">TopologicalMap::Initialize</a>  () override</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000057"></a>We could probably do this lazily if we use something like a segment tree to find the regions which intersect a cell. </p>
<p class="enddd"><a class="anchor" id="_todo000056"></a>Move this to the decomposition class, which currently cannot do this job because it does not know its own label.  </p>
</dd>
<dt>Global <a class="el" href="SSSP_8h.html#aabf6880e3d339fd68b493c212846299b">TwoVariableDijkstraSSSP</a>  (GraphType *const _g, const std::vector&lt; typename GraphType::vertex_descriptor &gt; &amp;_starts, std::unordered_set&lt; size_t &gt; _goals, const double _startTime, const double _minEndTime, const double _lastConstraint, const double _lastGoalConstraint, SSSPPathWeightFunction&lt; GraphType &gt; &amp;_weight)</dt>
<dd><a class="anchor" id="_todo000096"></a>If we want to add waiting, it should be added as a self edge here  </dd>
<dt>Class <a class="el" href="classWeightedEuclideanDistance.html">WeightedEuclideanDistance</a>  </dt>
<dd><a class="anchor" id="_todo000022"></a>This doesn't work properly for linked robots. An additional weighting is required for the joint space, which is currently wrapped up with orientation. </dd>
<dt>Global <a class="el" href="classWorkspaceDecomposition.html#af572ee3c2845a32ee6b14374fd8c8877">WorkspaceDecomposition::AddTetrahedralRegion</a>  (const int _pts[4])</dt>
<dd><a class="anchor" id="_todo000100"></a>The boundary currently double-stores the points. We would like to have a non-mutable boundary that holds only references to the points.  </dd>
<dt>Global <a class="el" href="classWorkspaceDecomposition.html#a7e25fc34b56f2dfe0d24b232556a08bc">WorkspaceDecomposition::FindNeighborhood</a>  (const std::vector&lt; size_t &gt; &amp;_roots, const double _threshold) const</dt>
<dd><a class="anchor" id="_todo000102"></a>Remove the const-cast after STAPL fixes its API.  </dd>
<dt>Global <a class="el" href="classWorkspaceDecomposition.html#a99a2feace3bb8d490eb086b26f09007c">WorkspaceDecomposition::FindPath</a>  (const size_t _source, const size_t _target) const</dt>
<dd><a class="anchor" id="_todo000101"></a>Remove the const-cast after STAPL fixes its API.  </dd>
<dt>Global <a class="el" href="classWorkspaceRegion.html#a9c0b6221d20efd44e0ef467232d688d1">WorkspaceRegion::FindSharedFacets</a>  (const <a class="el" href="classWorkspaceRegion.html">WorkspaceRegion</a> &amp;_wr) const noexcept</dt>
<dd><a class="anchor" id="_todo000103"></a>Eliminate this extraneous copy. Perhaps check if = reverse within facet class. </dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
