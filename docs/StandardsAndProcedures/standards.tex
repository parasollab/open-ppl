\documentclass[12pt]{article}

\usepackage[top=0.5in,left=0.5in,right=0.5in, bottom=0.5in]{geometry}
\usepackage{amssymb}
\usepackage{algorithm,algorithmic}
\newcommand{\EXCISE}[1]{}

\usepackage[usenames]{color}
\usepackage{listings}
\definecolor{LightGrey}{rgb}{0.9,0.9,0.9} 
\lstdefinestyle{C++}{language=C++,%
  backgroundcolor=\color{LightGrey},
  showstringspaces=false,
  columns=fullflexible,
  escapechar=@,
  basicstyle=\sffamily,
  moredelim=**[is][\color{white}]{~}{~},
  literate={=>}{{$\Rightarrow\;$}}1 {->}{{$\rightarrow{}$}}1 %
  {<-}{{$\leftarrow$}}1 {<:}{{$\subtype{}\ $}}1,
}

\title{\Large \bf Standards and Procedures of PMPL}
\author{Jory Denny and Shawna Thomas and Nancy M. Amato}

\begin{document}
\thispagestyle{empty}
\pagestyle{empty}
\maketitle
\lstset{style=C++}

This document outlines the standards for all procedures within PMPL. This ranges from coding standards, to testing
standards, to documentation standards, etc. Everyone will be expected to adhere to these standards.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PMPL Check-in procedure 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Check-in Procedure}
The following procedure will occur anytime a check-in will take place within PMPL.
\begin{algorithmic}[1]
\STATE One person will check over correctness and testing for proposed code.
\STATE A separate person shall check over the coding and documentation standards set forth within this document.
\STATE Back up validation shall occur during the PMPL nightly tests, person who checks in the code is responsible for
fixing warnings and errors caused by the check-in
\end{algorithmic}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PMPL Coding Standards 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Coding Standards}

\subsection{.h/.cpp}
All classes and files will be split between .h/.cpp format when possible. Exceptions are templated functions, and templated
classes (avoided when possible). All .h files should have \#define guards with the name of the file in all caps with
\_H\_ at the end (e.g., for ExampleClass.h -- EXAMPLECLASS\_H\_).

\begin{lstlisting}
#ifndef CLASS_H_
#define CLASS_H_

class Class;

#endif
\end{lstlisting}

\subsection{Classes}
\subsubsection{Class Names}
All class names will begin with a capital letter and each successive word will be capitalized.

\begin{lstlisting}
class MyClass;
\end{lstlisting}

\subsubsection{Class Variables}
Class variables should be indicated with m\_ (e.g., m\_variableName). No type specification is necessary (i.e.,
m\_pVariable for a pointer).

\begin{lstlisting}
m_myVariableName;
\end{lstlisting}

\subsubsection{Function Parameter Names}
Function parameters should be indicated with an \_ (e.g., \_variableName).

\begin{lstlisting}
void MyFunction(int _a);
\end{lstlisting}

\subsection{All variable/function/class names}
All variables will be named in \emph{CamelCasing}. Class names and function names should begin with a capital letter (i.e.,
MyClass or MyFunction) while variables should begin with a lower case letter (i.e., m\_classVariable,
\_functionParameter, or tempVar).

\begin{lstlisting}
class MyClass;
void MyFunction(int _a);
int myVariableName;
\end{lstlisting}

\subsection{XML variable names}
Similarly to the class and variable names, within the XML and XML loading, names should be camel cased. Thus a class
name in XML such as RotateAtS should begin with a capital letter. Variable names will begin with lower case letter,
e.g., vcMethod or lpMethod.

\begin{lstlisting}
<XMLClassName label="label" myVariable="false"/>
\end{lstlisting}

\subsection{Pointer and Reference Type Specification}
When declaring a variable to be a pointer or reference the * or \& should be adjacent to the type:

\begin{lstlisting}
Type* pointerName;
Type& referenceName;
\end{lstlisting}

\subsection{Spaces/Tabbing}
All tab characters should be represented by 2 spaces (easy to make default in all editors, vim is recommended).

\subsection{Curly Braces}
Curly braces used in control flow, function definitions, or class definitions should be placed on the same line as the
statement.

\begin{lstlisting}
class MyClass {
  void MyFunction(){
    while(1){
    }
  }
}
\end{lstlisting}

\subsection{Function Call/Declaration}
Function calls or declarations which are "long" should be split between multiple lines when necessary to aid in reading
the code. In addition the return type and class/function names should be located on separate lines in the definition,
see the example class for a general example, or below for the template.

\begin{lstlisting}
ReturnClass
Class::Function(parameter list which may span multiple lines){
}
\end{lstlisting}

\subsection{MPBaseObject inherited variables/functions}
\subsubsection{m\_debug}
There will be a variable, m\_debug in the PMPL base class which will be used to determine when output occurs. This means
that there will be no \#Define statements for debug output. All debug output will be of the form:

\begin{lstlisting}
if(m_debug) 
  cout << "My debug statement";
\end{lstlisting}

\subsubsection{m\_recordKeep}
This variable will be used to toggle record keeping with an algorithm. Thus affecting output to the stat class or not.

\begin{lstlisting}
if(m_recordKeep) 
  _stats.IncLPStat("TotalIterations", 5);
\end{lstlisting}

\subsubsection{GetNameAndLabel()}
This function returns a unique identifier to this class based on XML input. Returns m\_name + "::" + m\_label. This
should be used in output and record keeping as compared to simply GetName().

\begin{lstlisting}
string callee = GetNameAndLabel();
\end{lstlisting}

\subsection{PrintOptions}
In all classes one function PrintOptions should be implemented which displays the values of the class variables at the
time of calling. This function can be called after XML initialization, but should not be called else where (at least in
checked-in code).

\begin{lstlisting}
void PrintOptions(ostream& _os){
  _os << GetNameAndLabel() << endl;
  //output rest of class values
}
\end{lstlisting}

\subsection{Example Class}
Example class is located in ExampleClass.h/.cpp within this same folder. And appended at the end of the file.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PMPL Class Structure 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Class Structure}
All algorithmic groups will be structured in a similar way. There are two basic classes. The first is the algorithmic
base (e.g., LocalPlannerMethod, SamplerMethod, or DistanceMetricMethod) and the second is the container class (e.g.,
LocalPlanners, Samplers, or DistanceMetrics). This section outlines standards for this coding structure.

\subsection{Container Class}
The container class should implement the following standards:

\begin{itemize}
\item The container class must extend private ElementSet and public MPBaseObject.
\item The container class shall contain no functions to perform computations, i.e., LocalPlanners should not make any
calls to LocalPlannerMethods to check node connectivity.
\item The container class shall contain a method GetMethod(string \_s), which calls \\ElementSet::GetElement(\_s).
\item Any access to a specific algorithmic method will be made through GetMethod, e.g., \\
GetMPProblem()$\rightarrow$GetDistanceMetrics()$\rightarrow$GetMethod(s).
\item The pointer to the container class shall be stored in MPProblem.
\end{itemize}

\subsection{Algorithmic Base Class}
The algorithmic base class should implement the following standards:

\begin{itemize}
\item The base class must extend public MPBaseObject.
\item The base class shall have at minimum one purely virtual function reserved for algorithmic purposes, i.e., distance
metric methods have the function Distance.
\item If more than one way to call the purely virtual function exists, the base class shall contain the overloaded
functions to lead all computations to the one purely virtual function, e.g., in the SamplerMethod base class there are
many overloaded Sample functions, but all of these eventually converge to calling the single purely virtual function
Sampler.
\item Only attributes shared among all algorithmic extensions should be stored in this class and loaded in through the
xml constructor/ParseXML function (and non-xml constructor).
\end{itemize}

\subsection{Algorithmic Extensions}
All algorithmic extensions and class hierarchies should be constructed in such a way to MAXIMIZE code reuse. If the
functionality can be used in a separate part of the code as well this is a good candidate for a utility function, i.e.,
calculating the clearance of a node.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Statistics 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Statistics, Metrics, and Evaluators}

\subsection{StatClass}
In general the StatClass is reserved as only a record keeper. It is used to aid in access and modifying of statistics
for the user. The StatClass therefore has two functions, record keeping and easy output of statistics. Any calculations
shall be done in Metric calculations stored in MetricUtils.h/.cpp and shall not explicitly be contained in the
StatClass.

\subsubsection{Generalized Statistics}
Statistics general to all algorithmic methods in an algorithmic set should be handled in the Algorithmic base class,
when possible, and these statistics warrant their own variable, e.g., collision detection calls, local planner method
attempts/successes. The StatClass aids in this output as well.

\subsubsection{Specialized Maps}
The StatClass shall contain map$<$string, double$>$ for each separate part of the code for use of specific metrics related
to the specific algorithms, i.e., ToggleLP has specific statistics a user might be interested in. The StatClass shall
aid in the output of such statistics as well.

\subsubsection{Use of clocks}
Although the ClockClass is a separate class, the StatClass provides nice access to and automatic output of timing
statistics. Thus, if a clock is to be used, a programmer should go through the StatClass, i.e., \_stats.StartClock("my
timer") instead of ClockClass c("my timer); c.StartClock(). 

\subsection{Metrics}
Metric calculations will be stored in MetricUtils.h/.cpp. These should be items which are usuable by any part of the
code, and generalized in such a manner. 

\subsection{Evaluators}
Evaluators exist for the purpose of comparing a metric to a user defined value, i.e. is the number of edges in my
roadmap greater than 100?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% DOCUMENTATION AND TESTING STANDARDS NOT SET
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\EXCISE{

\section{Documentation}
All documentation should be done with DOxygen. DOxygen standards used within PMPL are not decided upon yet.

\section{Testing}
Currently only nightly compilation testing occurs nightly. This should be expanded in the future.

}

\section{Example Class}
\subsection{ExampleClass.h}
\lstinputlisting{ExampleClass.h}

\subsection{ExampleClass.cpp}
\lstinputlisting{ExampleClass.cpp}

\end{document}
