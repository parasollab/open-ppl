<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Parasol Planning Library (PPL): FibonacciHeap&lt; State, Action &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="parasol_logo_transparent_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Parasol Planning Library (PPL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">FibonacciHeap&lt; State, Action &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="FibonocciHeap_8h_source.html">FibonocciHeap.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac2a01c2463a9316e21caace7529b87a7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classGenericStateGraph.html">GenericStateGraph</a>&lt; State, Action &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#ac2a01c2463a9316e21caace7529b87a7">StateGraph</a></td></tr>
<tr class="separator:ac2a01c2463a9316e21caace7529b87a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abfabc29f89239429d7c68debf09959d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#abfabc29f89239429d7c68debf09959d9">Fibonacci</a> (<a class="el" href="classFibonacciHeap.html#ac2a01c2463a9316e21caace7529b87a7">StateGraph</a> *_stateGraph)</td></tr>
<tr class="separator:abfabc29f89239429d7c68debf09959d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5da56bbfdab72aa71ee92b62f7619d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#a7a5da56bbfdab72aa71ee92b62f7619d">fib_heap_insert</a> (<a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *new_node, double key)</td></tr>
<tr class="separator:a7a5da56bbfdab72aa71ee92b62f7619d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8053c15e215a964236a378650340101"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#af8053c15e215a964236a378650340101">fib_heap_existing_to_root</a> (<a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *new_node)</td></tr>
<tr class="separator:af8053c15e215a964236a378650340101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7abd63902d9789cbda65b175b56399"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#a8c7abd63902d9789cbda65b175b56399">fib_heap_add_child</a> (<a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *parent_node, <a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *new_child_node)</td></tr>
<tr class="separator:a8c7abd63902d9789cbda65b175b56399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4feeef8f5531c32a86ce8292359b71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#a9c4feeef8f5531c32a86ce8292359b71">fib_heap_remove_node_from_root</a> (<a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *node)</td></tr>
<tr class="separator:a9c4feeef8f5531c32a86ce8292359b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9776973fddce6f6f9c2bd12cbe182f42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#a9776973fddce6f6f9c2bd12cbe182f42">fib_heap_link</a> (<a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *high_node, <a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *low_node)</td></tr>
<tr class="separator:a9776973fddce6f6f9c2bd12cbe182f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aae1833fafea80a5805bb13e8278c51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#a9aae1833fafea80a5805bb13e8278c51">fib_heap_consolidate</a> ()</td></tr>
<tr class="separator:a9aae1833fafea80a5805bb13e8278c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69139904c2903f554d46b78020dbf68b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#a69139904c2903f554d46b78020dbf68b">fib_heap_extract_min</a> ()</td></tr>
<tr class="separator:a69139904c2903f554d46b78020dbf68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d87d9cc0b9d715c37194062b59fdce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#a6d87d9cc0b9d715c37194062b59fdce1">fib_heap_cut</a> (<a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *node, <a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *node_parent)</td></tr>
<tr class="separator:a6d87d9cc0b9d715c37194062b59fdce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f7d06324179216a53140fa89cb0be6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#a83f7d06324179216a53140fa89cb0be6">fib_heap_cascading_cut</a> (<a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *node)</td></tr>
<tr class="separator:a83f7d06324179216a53140fa89cb0be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4d52985420caec15a38b6d55dd0ad6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#a6d4d52985420caec15a38b6d55dd0ad6">fib_heap_decrease_key</a> (<a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *node_inst, int new_key)</td></tr>
<tr class="separator:a6d4d52985420caec15a38b6d55dd0ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bc8c1133f05e63a9833ecab0e611f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#ac3bc8c1133f05e63a9833ecab0e611f4">fib_heap_delete</a> (<a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *node)</td></tr>
<tr class="separator:ac3bc8c1133f05e63a9833ecab0e611f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b97df96776f90240786e564519c7ff7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#a3b97df96776f90240786e564519c7ff7">get_min_distant_unmarked_node</a> (int *distance_to_dest, std::unordered_map&lt; size_t, bool &gt; marked)</td></tr>
<tr class="separator:a3b97df96776f90240786e564519c7ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115774a8b95effb248507f6751d72e83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#a115774a8b95effb248507f6751d72e83">get_min_distant_unmarked_node_fib_heap</a> (std::unordered_map&lt; size_t, <a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> * &gt; node_array, std::unordered_map&lt; size_t, bool &gt; marked)</td></tr>
<tr class="separator:a115774a8b95effb248507f6751d72e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f61d8067a3304226339bfde422025cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#a7f61d8067a3304226339bfde422025cb">dijkstra_fibanocci</a> (int src)</td></tr>
<tr class="separator:a7f61d8067a3304226339bfde422025cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0214fa2a80d910fbaf3bab5602f25c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFibonacciHeap.html#ae0214fa2a80d910fbaf3bab5602f25c5">check_connected</a> (graph *my_graph)</td></tr>
<tr class="separator:ae0214fa2a80d910fbaf3bab5602f25c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac2a01c2463a9316e21caace7529b87a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a01c2463a9316e21caace7529b87a7">&#9670;&nbsp;</a></span>StateGraph</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classGenericStateGraph.html">GenericStateGraph</a>&lt;State, Action&gt; <a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::<a class="el" href="classFibonacciHeap.html#ac2a01c2463a9316e21caace7529b87a7">StateGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae0214fa2a80d910fbaf3bab5602f25c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0214fa2a80d910fbaf3bab5602f25c5">&#9670;&nbsp;</a></span>check_connected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::check_connected </td>
          <td>(</td>
          <td class="paramtype">graph *&#160;</td>
          <td class="paramname"><em>my_graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function runs the Depth-First-Search to find if the graph is completely connected.</p>
<p>This function runs the Depth-First-Search to find if the graph is completely connected. This function check if the graph is connected by running Depth-Frist-Search on the graph. </p>

</div>
</div>
<a id="a7f61d8067a3304226339bfde422025cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f61d8067a3304226339bfde422025cb">&#9670;&nbsp;</a></span>dijkstra_fibanocci()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::dijkstra_fibanocci </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function creates a graph with the number of vertices specified by the user. This function implements the Dijkstra algorithm using the routine array way for calculating the next minimum distant vertex from the source node. This function calculates the minimum distant node using the fibonacci heap. This function implements the Dijkstra algorithm using the fibonacci heap. Source vertex is specified by the user as input. </p>

</div>
</div>
<a id="a8c7abd63902d9789cbda65b175b56399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7abd63902d9789cbda65b175b56399">&#9670;&nbsp;</a></span>fib_heap_add_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::fib_heap_add_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *&#160;</td>
          <td class="paramname"><em>parent_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *&#160;</td>
          <td class="paramname"><em>new_child_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function combines two fibonacci heaps. This function isn't required for Dijkstra implementation. This function adds the new_child_node to the parent_node child list. Degree of the parent in incremented by one as well to reflect to the node </p>

</div>
</div>
<a id="a83f7d06324179216a53140fa89cb0be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f7d06324179216a53140fa89cb0be6">&#9670;&nbsp;</a></span>fib_heap_cascading_cut()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::fib_heap_cascading_cut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This recursive function removes the nodes from heap if the child mark values are true. It goes from child to parent until it sees a parent whose child mark value is false. It sets the child mark of last parent as true since it just lost a child. </p>

</div>
</div>
<a id="a9aae1833fafea80a5805bb13e8278c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aae1833fafea80a5805bb13e8278c51">&#9670;&nbsp;</a></span>fib_heap_consolidate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::fib_heap_consolidate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is the crucial method for fibonacci heaps where all the actual time is spent in pairwise merging of all the trees, to ensure at the end of the operation there are no two trees with the same degree. we scan the root list with the help of min pointer in the heap and combine trees with same degree into a single tree. We do this with the help of a auxillary table to see if there is a tree with degree already existing in our heap. </p>

</div>
</div>
<a id="a6d87d9cc0b9d715c37194062b59fdce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d87d9cc0b9d715c37194062b59fdce1">&#9670;&nbsp;</a></span>fib_heap_cut()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::fib_heap_cut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *&#160;</td>
          <td class="paramname"><em>node_parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method removes the child node from its parent in the heap. </p>

</div>
</div>
<a id="a6d4d52985420caec15a38b6d55dd0ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4d52985420caec15a38b6d55dd0ad6">&#9670;&nbsp;</a></span>fib_heap_decrease_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::fib_heap_decrease_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *&#160;</td>
          <td class="paramname"><em>node_inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method sets the key field of node to amount specified as argument. Based on the new value it may be removed from the parent and called for cut and cascade methods. </p>

</div>
</div>
<a id="ac3bc8c1133f05e63a9833ecab0e611f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bc8c1133f05e63a9833ecab0e611f4">&#9670;&nbsp;</a></span>fib_heap_delete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::fib_heap_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be used to delete a key from the heap. This is achieved by decreasing the key value to the minimum value available in the data type being used. This function is not in use for our current implementation. </p>

</div>
</div>
<a id="af8053c15e215a964236a378650340101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8053c15e215a964236a378650340101">&#9670;&nbsp;</a></span>fib_heap_existing_to_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::fib_heap_existing_to_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *&#160;</td>
          <td class="paramname"><em>new_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function deals with adding truncated nodes to the root list. mark value of the node is set to FALSE as it is equivalent to the node being insert first time. </p>

</div>
</div>
<a id="a69139904c2903f554d46b78020dbf68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69139904c2903f554d46b78020dbf68b">&#9670;&nbsp;</a></span>fib_heap_extract_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> * <a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::fib_heap_extract_min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function extracts the minimum value from the heap based on the min_node pointer that each heap structure maintains. In order to verify the correctness of the fibonacci implementation with the array one, I am writing out each extracted min node to a file for making the comparision easier. </p>

</div>
</div>
<a id="a7a5da56bbfdab72aa71ee92b62f7619d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5da56bbfdab72aa71ee92b62f7619d">&#9670;&nbsp;</a></span>fib_heap_insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::fib_heap_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *&#160;</td>
          <td class="paramname"><em>new_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Node structure in a Graph. Instead, we are simplifying by representing each node by its index (int) Structure for each element in a Graph's adjacency list Adjacency list representation of the graph. We use a Hash Table to map each vertex to its adjacent nodes This is the fibonacci heap data structure which has min pointer of type fibonacci node and total nodes in the heap This function inserts a new node into the fibonacci heap. Depending on the key mentioned, heap min pointer is changed appropriately and degree incremented by one. </p>

</div>
</div>
<a id="a9776973fddce6f6f9c2bd12cbe182f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9776973fddce6f6f9c2bd12cbe182f42">&#9670;&nbsp;</a></span>fib_heap_link()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::fib_heap_link </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *&#160;</td>
          <td class="paramname"><em>high_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *&#160;</td>
          <td class="paramname"><em>low_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function links two nodes as part of the consolidation operation. First the larger node is sliced from its sibling list and is then added as a child to the smaller node </p>

</div>
</div>
<a id="a9c4feeef8f5531c32a86ce8292359b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4feeef8f5531c32a86ce8292359b71">&#9670;&nbsp;</a></span>fib_heap_remove_node_from_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::fib_heap_remove_node_from_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to truncate a child node from a sibling list. It could be a root list as well. </p>

</div>
</div>
<a id="abfabc29f89239429d7c68debf09959d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfabc29f89239429d7c68debf09959d9">&#9670;&nbsp;</a></span>Fibonacci()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::Fibonacci </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFibonacciHeap.html#ac2a01c2463a9316e21caace7529b87a7">StateGraph</a> *&#160;</td>
          <td class="paramname"><em>_stateGraph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b97df96776f90240786e564519c7ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b97df96776f90240786e564519c7ff7">&#9670;&nbsp;</a></span>get_min_distant_unmarked_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::get_min_distant_unmarked_node </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>distance_to_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; size_t, bool &gt;&#160;</td>
          <td class="paramname"><em>marked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function calculates the min distant unmarked node using the normal array implementation. This uses the Greedy approach. </p>

</div>
</div>
<a id="a115774a8b95effb248507f6751d72e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115774a8b95effb248507f6751d72e83">&#9670;&nbsp;</a></span>get_min_distant_unmarked_node_fib_heap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classFibonacciHeap.html">FibonacciHeap</a>&lt; State, Action &gt;::get_min_distant_unmarked_node_fib_heap </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; size_t, <a class="el" href="structFibonacciHeap_1_1FibonacciNode.html">FibonacciNode</a> * &gt;&#160;</td>
          <td class="paramname"><em>node_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; size_t, bool &gt;&#160;</td>
          <td class="paramname"><em>marked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function calculates the minimum distant node using the fibonacci heap. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/opt/actions-runner/_work/open-ppl/open-ppl/src/Utilities/<a class="el" href="FibonocciHeap_8h_source.html">FibonocciHeap.h</a></li>
<li>/opt/actions-runner/_work/open-ppl/open-ppl/src/Utilities/<a class="el" href="FibonocciHeap_8cpp.html">FibonocciHeap.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
