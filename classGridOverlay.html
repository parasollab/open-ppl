<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Parasol Planning Library (PPL): GridOverlay Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="parasol_logo_transparent_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Parasol Planning Library (PPL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">GridOverlay Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="GridOverlay_8h_source.html">GridOverlay.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Local Types</div></td></tr>
<tr class="memitem:afcf6fc05b418b5123c9bc28012505400"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400">CellSet</a> : unsigned char { <a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400ae234de581c9c5ef91322f1469a585f9e">Boundary</a> = 1
, <a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400aebbcc9b3b8fc5c7d79d0126910b82a69">Interior</a> = 2
, <a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400aaf4bb376939e77df0e7c2332b837a866">Closure</a> = 3
 }</td></tr>
<tr class="memdesc:afcf6fc05b418b5123c9bc28012505400"><td class="mdescLeft">&#160;</td><td class="mdescRight">The types of cell sets for use with LocateCells.  <a href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400">More...</a><br /></td></tr>
<tr class="separator:afcf6fc05b418b5123c9bc28012505400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73518b6b39a5c8869cf56beec31ad906"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; std::vector&lt; const <a class="el" href="classWorkspaceRegion.html">WorkspaceRegion</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a73518b6b39a5c8869cf56beec31ad906">DecompositionMap</a></td></tr>
<tr class="memdesc:a73518b6b39a5c8869cf56beec31ad906"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mapping from a grid cell index to a set of workspace regions.  <a href="classGridOverlay.html#a73518b6b39a5c8869cf56beec31ad906">More...</a><br /></td></tr>
<tr class="separator:a73518b6b39a5c8869cf56beec31ad906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474ed0ab01122170f0735fcabacefc4f"><td class="memItemLeft" align="right" valign="top">typedef std::array&lt; size_t, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a474ed0ab01122170f0735fcabacefc4f">IndexSet</a></td></tr>
<tr class="memdesc:a474ed0ab01122170f0735fcabacefc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of X, Y, Z indexes for a grid cell.  <a href="classGridOverlay.html#a474ed0ab01122170f0735fcabacefc4f">More...</a><br /></td></tr>
<tr class="separator:a474ed0ab01122170f0735fcabacefc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a51afef65aa767d4229438d8b2ff2a655"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a51afef65aa767d4229438d8b2ff2a655">GridOverlay</a> (const <a class="el" href="classBoundary.html">Boundary</a> *const _b, const double _length)</td></tr>
<tr class="separator:a51afef65aa767d4229438d8b2ff2a655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ba4f5415c77a978084d5e12f896261"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#ad0ba4f5415c77a978084d5e12f896261">~GridOverlay</a> () noexcept</td></tr>
<tr class="separator:ad0ba4f5415c77a978084d5e12f896261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell Finders</div></td></tr>
<tr class="memitem:aaf5a20d3e8ad1e8a5d43764a1c3535c8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#aaf5a20d3e8ad1e8a5d43764a1c3535c8">Size</a> () const noexcept</td></tr>
<tr class="memdesc:aaf5a20d3e8ad1e8a5d43764a1c3535c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of cells in the grid.  <a href="classGridOverlay.html#aaf5a20d3e8ad1e8a5d43764a1c3535c8">More...</a><br /></td></tr>
<tr class="separator:aaf5a20d3e8ad1e8a5d43764a1c3535c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdba9adc448be3a77dfa1d3bb33e5366"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#abdba9adc448be3a77dfa1d3bb33e5366">Size</a> (const size_t _i) const noexcept</td></tr>
<tr class="separator:abdba9adc448be3a77dfa1d3bb33e5366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e6ec21ca468c2aea5d8c6d04f1fe1d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a40e6ec21ca468c2aea5d8c6d04f1fe1d">LocateCell</a> (const <a class="el" href="classCfg.html">Cfg</a> &amp;_cfg) const</td></tr>
<tr class="separator:a40e6ec21ca468c2aea5d8c6d04f1fe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa819183185181c09f434f8ed17da6e33"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#aa819183185181c09f434f8ed17da6e33">LocateCell</a> (const Point3d &amp;_p) const</td></tr>
<tr class="separator:aa819183185181c09f434f8ed17da6e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245056ab21132e5b6151b2522fafd126"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a245056ab21132e5b6151b2522fafd126">LocateCells</a> (const <a class="el" href="classBoundary.html">Boundary</a> *const _b, const <a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400">CellSet</a> _type=<a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400aaf4bb376939e77df0e7c2332b837a866">CellSet::Closure</a>) const</td></tr>
<tr class="separator:a245056ab21132e5b6151b2522fafd126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b009d33707877f4e4e716819d9f8ffe"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a5b009d33707877f4e4e716819d9f8ffe">LocateCells</a> (const <a class="el" href="classGMSPolyhedron.html">GMSPolyhedron</a> &amp;_polyhedron, const mathtool::Transformation &amp;_transformation={}, const <a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400">CellSet</a> _type=<a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400aaf4bb376939e77df0e7c2332b837a866">CellSet::Closure</a>) const</td></tr>
<tr class="separator:a5b009d33707877f4e4e716819d9f8ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4fac7a1e567afec6dd680f94259066"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a1b4fac7a1e567afec6dd680f94259066">LocateBBXCells</a> (const <a class="el" href="classBoundary.html">Boundary</a> *const _b) const</td></tr>
<tr class="separator:a1b4fac7a1e567afec6dd680f94259066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2715d2da1ea89d584d6d3156a2429461"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a2715d2da1ea89d584d6d3156a2429461">LocateBBXCells</a> (const Point3d &amp;_min, const Point3d &amp;_max) const</td></tr>
<tr class="separator:a2715d2da1ea89d584d6d3156a2429461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b19b87196fbfd7c8bc1640b59a6644"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a00b19b87196fbfd7c8bc1640b59a6644">LocateFacetNeighbors</a> (const size_t _index) const</td></tr>
<tr class="separator:a00b19b87196fbfd7c8bc1640b59a6644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4119b768dc1ca2cd9fcb5ff9fecaddee"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a4119b768dc1ca2cd9fcb5ff9fecaddee">LocateEdgeNeighbors</a> (const size_t _index) const</td></tr>
<tr class="separator:a4119b768dc1ca2cd9fcb5ff9fecaddee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de4712a6837b0cb9e72b23be9957eb0"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a3de4712a6837b0cb9e72b23be9957eb0">LocateVertexNeighbors</a> (const size_t _index) const</td></tr>
<tr class="separator:a3de4712a6837b0cb9e72b23be9957eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c0c1fda2f7092310d3b5cc77a5d57a"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a89c0c1fda2f7092310d3b5cc77a5d57a">LocateAllNeighbors</a> (const size_t _index) const</td></tr>
<tr class="separator:a89c0c1fda2f7092310d3b5cc77a5d57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell Properties</div></td></tr>
<tr class="memitem:a38e78aaeae73d5abb6b85e6ceee4acc7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a38e78aaeae73d5abb6b85e6ceee4acc7">CellLength</a> () const noexcept</td></tr>
<tr class="memdesc:a38e78aaeae73d5abb6b85e6ceee4acc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the grid cells.  <a href="classGridOverlay.html#a38e78aaeae73d5abb6b85e6ceee4acc7">More...</a><br /></td></tr>
<tr class="separator:a38e78aaeae73d5abb6b85e6ceee4acc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be0d2e86ffa2d02f94f4cad75daeaa3"><td class="memItemLeft" align="right" valign="top">Point3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a0be0d2e86ffa2d02f94f4cad75daeaa3">CellCenter</a> (const size_t _index) const noexcept</td></tr>
<tr class="separator:a0be0d2e86ffa2d02f94f4cad75daeaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Decomposition Mapping</div></td></tr>
<tr class="memitem:ae49f0c6cb2dc27e7c49908668424fa6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGridOverlay.html#a73518b6b39a5c8869cf56beec31ad906">DecompositionMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#ae49f0c6cb2dc27e7c49908668424fa6d">ComputeDecompositionMap</a> (const <a class="el" href="classWorkspaceDecomposition.html">WorkspaceDecomposition</a> *const _decomposition, const bool _useCollisionDetection=false) const</td></tr>
<tr class="separator:ae49f0c6cb2dc27e7c49908668424fa6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Testing</div></td></tr>
<tr class="memitem:ae8a81507e5dd6d54da3ebfeba14b1a7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#ae8a81507e5dd6d54da3ebfeba14b1a7e">Test</a> (const size_t _trials=0) const</td></tr>
<tr class="separator:ae8a81507e5dd6d54da3ebfeba14b1a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A 3d grid overlay of a given boundary.</p>
<p>The cells are implicitly represented as either a tuple (x,y,z) or a single 'cell index', which enumerates all cells with a single number. The grid is defined over the minimum and maximum ranges of the boundary, so there may be grid cells partially or completely outside of the boundary (depending its shape and size).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000115">Todo:</a></b></dt><dd>Generalize to support 2d grids as well as 3d.</dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a73518b6b39a5c8869cf56beec31ad906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73518b6b39a5c8869cf56beec31ad906">&#9670;&nbsp;</a></span>DecompositionMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;std::vector&lt;const <a class="el" href="classWorkspaceRegion.html">WorkspaceRegion</a>*&gt; &gt; <a class="el" href="classGridOverlay.html#a73518b6b39a5c8869cf56beec31ad906">GridOverlay::DecompositionMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A mapping from a grid cell index to a set of workspace regions. </p>

</div>
</div>
<a id="a474ed0ab01122170f0735fcabacefc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474ed0ab01122170f0735fcabacefc4f">&#9670;&nbsp;</a></span>IndexSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::array&lt;size_t, 3&gt; <a class="el" href="classGridOverlay.html#a474ed0ab01122170f0735fcabacefc4f">GridOverlay::IndexSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A set of X, Y, Z indexes for a grid cell. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="afcf6fc05b418b5123c9bc28012505400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf6fc05b418b5123c9bc28012505400">&#9670;&nbsp;</a></span>CellSet</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400">GridOverlay::CellSet</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The types of cell sets for use with LocateCells. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afcf6fc05b418b5123c9bc28012505400ae234de581c9c5ef91322f1469a585f9e"></a>Boundary&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afcf6fc05b418b5123c9bc28012505400aebbcc9b3b8fc5c7d79d0126910b82a69"></a>Interior&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afcf6fc05b418b5123c9bc28012505400aaf4bb376939e77df0e7c2332b837a866"></a>Closure&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a51afef65aa767d4229438d8b2ff2a655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51afef65aa767d4229438d8b2ff2a655">&#9670;&nbsp;</a></span>GridOverlay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridOverlay::GridOverlay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a grid overlay with cells of a given length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_b</td><td>The boundary to overlay. </td></tr>
    <tr><td class="paramname">_length</td><td>The cell length to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0ba4f5415c77a978084d5e12f896261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ba4f5415c77a978084d5e12f896261">&#9670;&nbsp;</a></span>~GridOverlay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridOverlay::~GridOverlay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0be0d2e86ffa2d02f94f4cad75daeaa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be0d2e86ffa2d02f94f4cad75daeaa3">&#9670;&nbsp;</a></span>CellCenter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Point3d GridOverlay::CellCenter </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the center of a cell. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_index</td><td>The cell index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The center of cell _index. </dd></dl>

</div>
</div>
<a id="a38e78aaeae73d5abb6b85e6ceee4acc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e78aaeae73d5abb6b85e6ceee4acc7">&#9670;&nbsp;</a></span>CellLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double GridOverlay::CellLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the grid cells. </p>

</div>
</div>
<a id="ae49f0c6cb2dc27e7c49908668424fa6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49f0c6cb2dc27e7c49908668424fa6d">&#9670;&nbsp;</a></span>ComputeDecompositionMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGridOverlay.html#a73518b6b39a5c8869cf56beec31ad906">GridOverlay::DecompositionMap</a> GridOverlay::ComputeDecompositionMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWorkspaceDecomposition.html">WorkspaceDecomposition</a> *const&#160;</td>
          <td class="paramname"><em>_decomposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>_useCollisionDetection</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a map from grid cell index to the set of decomposition regions which are near to or touch the grid cell. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_decomposition</td><td>The workspace decomposition object to map. </td></tr>
    <tr><td class="paramname">_useCollisionDetection</td><td>Use <a class="el" href="classPQP.html">PQP</a> collision detection to refine the test? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mapping m, where m[i] gives a set of _decomposition regions. If not using <a class="el" href="classPQP.html">PQP</a> then the regions are those whos BBX touches grid cell i, otherwise the regions actually touch cell i. </dd></dl>

</div>
</div>
<a id="a89c0c1fda2f7092310d3b5cc77a5d57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c0c1fda2f7092310d3b5cc77a5d57a">&#9670;&nbsp;</a></span>LocateAllNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; size_t &gt; GridOverlay::LocateAllNeighbors </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locate all neighbors of a cell. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_index</td><td>The cell index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The neighbor cell indexes. </dd></dl>

</div>
</div>
<a id="a1b4fac7a1e567afec6dd680f94259066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4fac7a1e567afec6dd680f94259066">&#9670;&nbsp;</a></span>LocateBBXCells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; size_t &gt; GridOverlay::LocateBBXCells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the cells that contain a given boundary's bounding box. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_b</td><td>The boundary of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of cell indexes that contain _b's bounding box. </dd></dl>

</div>
</div>
<a id="a2715d2da1ea89d584d6d3156a2429461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2715d2da1ea89d584d6d3156a2429461">&#9670;&nbsp;</a></span>LocateBBXCells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; size_t &gt; GridOverlay::LocateBBXCells </td>
          <td>(</td>
          <td class="paramtype">const Point3d &amp;&#160;</td>
          <td class="paramname"><em>_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point3d &amp;&#160;</td>
          <td class="paramname"><em>_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the cells that contain a bounding box around two points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_min</td><td>The low-range values. </td></tr>
    <tr><td class="paramname">_max</td><td>The high-range values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of cell indexes that contain the bounding box around _min, _max. </dd></dl>

</div>
</div>
<a id="a40e6ec21ca468c2aea5d8c6d04f1fe1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e6ec21ca468c2aea5d8c6d04f1fe1d">&#9670;&nbsp;</a></span>LocateCell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GridOverlay::LocateCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCfg.html">Cfg</a> &amp;&#160;</td>
          <td class="paramname"><em>_cfg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the cell that contains the reference point of a configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cfg</td><td>The configuration to locate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the cell which contains _cfg's translational DOFs. </dd></dl>

</div>
</div>
<a id="aa819183185181c09f434f8ed17da6e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa819183185181c09f434f8ed17da6e33">&#9670;&nbsp;</a></span>LocateCell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GridOverlay::LocateCell </td>
          <td>(</td>
          <td class="paramtype">const Point3d &amp;&#160;</td>
          <td class="paramname"><em>_p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the cell that contains a reference point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_p</td><td>The point to locate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the cell which contains _p. </dd></dl>

</div>
</div>
<a id="a245056ab21132e5b6151b2522fafd126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245056ab21132e5b6151b2522fafd126">&#9670;&nbsp;</a></span>LocateCells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; size_t &gt; GridOverlay::LocateCells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400">CellSet</a>&#160;</td>
          <td class="paramname"><em>_type</em> = <code><a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400aaf4bb376939e77df0e7c2332b837a866">CellSet::Closure</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the cells that touch a given boundary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_b</td><td>The boundary of interest. </td></tr>
    <tr><td class="paramname">_type</td><td>The type of cell set to include. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of cell indexes that touch _b as described by _type. </dd></dl>

</div>
</div>
<a id="a5b009d33707877f4e4e716819d9f8ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b009d33707877f4e4e716819d9f8ffe">&#9670;&nbsp;</a></span>LocateCells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; size_t &gt; GridOverlay::LocateCells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGMSPolyhedron.html">GMSPolyhedron</a> &amp;&#160;</td>
          <td class="paramname"><em>_polyhedron</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mathtool::Transformation &amp;&#160;</td>
          <td class="paramname"><em>_transformation</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400">CellSet</a>&#160;</td>
          <td class="paramname"><em>_type</em> = <code><a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400aaf4bb376939e77df0e7c2332b837a866">CellSet::Closure</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the cells that touch a given polyhedron. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_polyhedron</td><td>The polyhedron of interest. </td></tr>
    <tr><td class="paramname">_transformation</td><td>The transformation for _polyhedron. </td></tr>
    <tr><td class="paramname">_type</td><td>The type of cell set to include. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of cell indexes that touch _polyhedron as described by _type. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000113">Todo:</a></b></dt><dd>Can make the !_interior version more efficient by computing bbx cells for each facet. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000114">Todo:</a></b></dt><dd>Can make both versions more efficient by avoiding re-building the _polyhedron's BBX each time. Add min/max pts and transform them with the poly, use here. </dd></dl>

</div>
</div>
<a id="a4119b768dc1ca2cd9fcb5ff9fecaddee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4119b768dc1ca2cd9fcb5ff9fecaddee">&#9670;&nbsp;</a></span>LocateEdgeNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; size_t &gt; GridOverlay::LocateEdgeNeighbors </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locate the neighbors of a cell which share an edge but not a facet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_index</td><td>The cell index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The neighbor cell indexes. </dd></dl>

</div>
</div>
<a id="a00b19b87196fbfd7c8bc1640b59a6644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b19b87196fbfd7c8bc1640b59a6644">&#9670;&nbsp;</a></span>LocateFacetNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; size_t &gt; GridOverlay::LocateFacetNeighbors </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locate the neighbors of a cell which share a facet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_index</td><td>The cell index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The neighbor cell indexes. </dd></dl>

</div>
</div>
<a id="a3de4712a6837b0cb9e72b23be9957eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de4712a6837b0cb9e72b23be9957eb0">&#9670;&nbsp;</a></span>LocateVertexNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; size_t &gt; GridOverlay::LocateVertexNeighbors </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locate the neighbors of a cell which share a vertex but not an edge or facet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_index</td><td>The cell index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The neighbor cell indexes. </dd></dl>

</div>
</div>
<a id="aaf5a20d3e8ad1e8a5d43764a1c3535c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5a20d3e8ad1e8a5d43764a1c3535c8">&#9670;&nbsp;</a></span>Size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t GridOverlay::Size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of cells in the grid. </p>

</div>
</div>
<a id="abdba9adc448be3a77dfa1d3bb33e5366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdba9adc448be3a77dfa1d3bb33e5366">&#9670;&nbsp;</a></span>Size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t GridOverlay::Size </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>_i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of cells in a given dimension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_i</td><td>The index for the dimension of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of cells in dimension _i. </dd></dl>

</div>
</div>
<a id="ae8a81507e5dd6d54da3ebfeba14b1a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a81507e5dd6d54da3ebfeba14b1a7e">&#9670;&nbsp;</a></span>Test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridOverlay::Test </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>_trials</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test this object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_trials</td><td>Sample this number of grid cells to test. Or, use zero to test all cells. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the test fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/opt/actions-runner/_work/open-ppl/open-ppl/src/Workspace/<a class="el" href="GridOverlay_8h_source.html">GridOverlay.h</a></li>
<li>/opt/actions-runner/_work/open-ppl/open-ppl/src/Workspace/<a class="el" href="GridOverlay_8cpp.html">GridOverlay.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
