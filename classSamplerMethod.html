<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Parasol Planning Library (PPL): SamplerMethod Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="parasol_logo_transparent_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Parasol Planning Library (PPL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">SamplerMethod Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="SamplerMethod_8h_source.html">SamplerMethod.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SamplerMethod:</div>
<div class="dyncontent">
<div class="center"><img src="classSamplerMethod__inherit__graph.png" border="0" usemap="#aSamplerMethod_inherit__map" alt="Inheritance graph"/></div>
<map name="aSamplerMethod_inherit__map" id="aSamplerMethod_inherit__map">
<area shape="rect" title=" " alt="" coords="169,132,295,159"/>
<area shape="rect" href="classBridgeTestSampler.html" title="This sampler validity checks the input sample and accepts it iff it passes the bridge test &#45; i...." alt="" coords="384,5,528,32"/>
<area shape="rect" href="classGaussianSampler.html" title="Gaussian&#45;distribution based sampling." alt="" coords="388,56,524,83"/>
<area shape="rect" href="classMixSampler.html" title=" " alt="" coords="406,107,506,133"/>
<area shape="rect" href="classObstacleBasedSampler.html" title="Obstacle&#45;based sampling." alt="" coords="369,157,543,184"/>
<area shape="rect" href="classUniformObstacleBasedSampler.html" title=" " alt="" coords="343,208,569,235"/>
<area shape="rect" href="classUniformRandomSampler.html" title=" " alt="" coords="365,259,547,285"/>
<area shape="rect" href="classMPBaseObject.html" title=" " alt="" coords="5,132,121,159"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for SamplerMethod:</div>
<div class="dyncontent">
<div class="center"><img src="classSamplerMethod__coll__graph.png" border="0" usemap="#aSamplerMethod_coll__map" alt="Collaboration graph"/></div>
<map name="aSamplerMethod_coll__map" id="aSamplerMethod_coll__map">
<area shape="rect" title=" " alt="" coords="5,80,131,107"/>
<area shape="rect" href="classMPBaseObject.html" title=" " alt="" coords="10,5,126,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Motion Planning Types</div></td></tr>
<tr class="memitem:a4d2315534d97771e3f262573054a64be"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">MPBaseObject::GroupCfgType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a4d2315534d97771e3f262573054a64be">GroupCfgType</a></td></tr>
<tr class="separator:a4d2315534d97771e3f262573054a64be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Local Types</div></td></tr>
<tr class="memitem:a914d9dc5ae04bf467c3116c058da0757"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classCfg.html">Cfg</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a914d9dc5ae04bf467c3116c058da0757">InputIterator</a></td></tr>
<tr class="separator:a914d9dc5ae04bf467c3116c058da0757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87095150c507a033d88a8f3de99b70ce"><td class="memItemLeft" align="right" valign="top">typedef std::back_insert_iterator&lt; std::vector&lt; <a class="el" href="classCfg.html">Cfg</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a></td></tr>
<tr class="separator:a87095150c507a033d88a8f3de99b70ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d655628d748e2ea08d813a3d73bd4c0"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a5d655628d748e2ea08d813a3d73bd4c0">GroupInputIterator</a></td></tr>
<tr class="separator:a5d655628d748e2ea08d813a3d73bd4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47218ae4716273df3d40038e0396db9"><td class="memItemLeft" align="right" valign="top">typedef std::back_insert_iterator&lt; std::vector&lt; <a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a></td></tr>
<tr class="separator:ad47218ae4716273df3d40038e0396db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f6944c978c28770334f8d519c18d9f"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="classRobot.html">Robot</a> *, const <a class="el" href="classBoundary.html">Boundary</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a84f6944c978c28770334f8d519c18d9f">BoundaryMap</a></td></tr>
<tr class="memdesc:a84f6944c978c28770334f8d519c18d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from robots to sampling boundaries.  <a href="classSamplerMethod.html#a84f6944c978c28770334f8d519c18d9f">More...</a><br /></td></tr>
<tr class="separator:a84f6944c978c28770334f8d519c18d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classMPBaseObject"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classMPBaseObject')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classMPBaseObject.html">MPBaseObject</a></td></tr>
<tr class="memitem:a63f3af4b78d458b51ddad699de1f9287 inherit pub_types_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDefaultWeight.html">DefaultWeight</a>&lt; <a class="el" href="classCfg.html">Cfg</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a63f3af4b78d458b51ddad699de1f9287">WeightType</a></td></tr>
<tr class="separator:a63f3af4b78d458b51ddad699de1f9287 inherit pub_types_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb9a08003cc7620b1534bdf69ceb1a4 inherit pub_types_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classGenericStateGraph.html">GenericStateGraph</a>&lt; <a class="el" href="classCfg.html">Cfg</a>, <a class="el" href="classMPBaseObject.html#a63f3af4b78d458b51ddad699de1f9287">WeightType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a1cb9a08003cc7620b1534bdf69ceb1a4">RoadmapType</a></td></tr>
<tr class="separator:a1cb9a08003cc7620b1534bdf69ceb1a4 inherit pub_types_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3c1d1dccb02cfd48da4438a2b2923b inherit pub_types_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classGroupCfg.html">GroupCfg</a>&lt; <a class="el" href="classMPBaseObject.html#a1cb9a08003cc7620b1534bdf69ceb1a4">RoadmapType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a></td></tr>
<tr class="separator:aad3c1d1dccb02cfd48da4438a2b2923b inherit pub_types_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26059613b8543b300ece8b511aad7050 inherit pub_types_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classGroupLocalPlan.html">GroupLocalPlan</a>&lt; <a class="el" href="classMPBaseObject.html#a1cb9a08003cc7620b1534bdf69ceb1a4">RoadmapType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a26059613b8543b300ece8b511aad7050">GroupWeightType</a></td></tr>
<tr class="separator:a26059613b8543b300ece8b511aad7050 inherit pub_types_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062f6026973104069b7e08eb23a890f7 inherit pub_types_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classGroupRoadmap.html">GroupRoadmap</a>&lt; <a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a>, <a class="el" href="classMPBaseObject.html#a26059613b8543b300ece8b511aad7050">GroupWeightType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a062f6026973104069b7e08eb23a890f7">GroupRoadmapType</a></td></tr>
<tr class="separator:a062f6026973104069b7e08eb23a890f7 inherit pub_types_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a36bbf5f98d952b0feec38e4961eacb60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a36bbf5f98d952b0feec38e4961eacb60">SamplerMethod</a> ()=default</td></tr>
<tr class="separator:a36bbf5f98d952b0feec38e4961eacb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2048574fd46691a2fbadff23b5ac12c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a2048574fd46691a2fbadff23b5ac12c2">SamplerMethod</a> (<a class="el" href="classXMLNode.html">XMLNode</a> &amp;_node)</td></tr>
<tr class="separator:a2048574fd46691a2fbadff23b5ac12c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7425beb78efe71a47f7086713ae9e681"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a7425beb78efe71a47f7086713ae9e681">~SamplerMethod</a> ()=0</td></tr>
<tr class="separator:a7425beb78efe71a47f7086713ae9e681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Individual Configuration Sampling</div></td></tr>
<tr class="memitem:a93f731d73ed5f838737e450b07031e2c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a93f731d73ed5f838737e450b07031e2c">Sample</a> (size_t _numNodes, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, <a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a> _valid, <a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a> _invalid)</td></tr>
<tr class="separator:a93f731d73ed5f838737e450b07031e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83a1674031e57439b6a01f2c80cbdf6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#ad83a1674031e57439b6a01f2c80cbdf6">Sample</a> (size_t _numNodes, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, <a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a> _valid)</td></tr>
<tr class="memdesc:ad83a1674031e57439b6a01f2c80cbdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classSamplerMethod.html#ad83a1674031e57439b6a01f2c80cbdf6">More...</a><br /></td></tr>
<tr class="separator:ad83a1674031e57439b6a01f2c80cbdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8345e3a12f62693cc8e72f5a63528117"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a8345e3a12f62693cc8e72f5a63528117">Sample</a> (size_t _numNodes, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _robotBoundary, const <a class="el" href="classBoundary.html">Boundary</a> *const _eeBoundary, <a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a> _valid, <a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a> _invalid)</td></tr>
<tr class="separator:a8345e3a12f62693cc8e72f5a63528117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1999e4f3b7ec4b70cf68e4581ca480"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a8d1999e4f3b7ec4b70cf68e4581ca480">Sample</a> (size_t _numNodes, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _robotBoundary, const <a class="el" href="classBoundary.html">Boundary</a> *const _eeBoundary, <a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a> _valid)</td></tr>
<tr class="separator:a8d1999e4f3b7ec4b70cf68e4581ca480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2494b15fd4815d8d0aed9c2f1e21e0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a8a2494b15fd4815d8d0aed9c2f1e21e0">Filter</a> (<a class="el" href="classSamplerMethod.html#a914d9dc5ae04bf467c3116c058da0757">InputIterator</a> _first, <a class="el" href="classSamplerMethod.html#a914d9dc5ae04bf467c3116c058da0757">InputIterator</a> _last, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, <a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a> _valid, <a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a> _invalid)</td></tr>
<tr class="separator:a8a2494b15fd4815d8d0aed9c2f1e21e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c939aa5b5f15b052ae10ee693c0d832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a4c939aa5b5f15b052ae10ee693c0d832">Filter</a> (<a class="el" href="classSamplerMethod.html#a914d9dc5ae04bf467c3116c058da0757">InputIterator</a> _first, <a class="el" href="classSamplerMethod.html#a914d9dc5ae04bf467c3116c058da0757">InputIterator</a> _last, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, <a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a> _valid)</td></tr>
<tr class="separator:a4c939aa5b5f15b052ae10ee693c0d832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Group Configuration Sampling</div></td></tr>
<tr class="memitem:ad0a233df53eadb9e0b3dfdda54022cc6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#ad0a233df53eadb9e0b3dfdda54022cc6">Sample</a> (size_t _numNodes, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, <a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a> _valid, <a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a> _invalid)</td></tr>
<tr class="separator:ad0a233df53eadb9e0b3dfdda54022cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a385b1549cfec52bd5d4dfa141ac92"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a15a385b1549cfec52bd5d4dfa141ac92">Sample</a> (size_t _numNodes, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, <a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a> _valid)</td></tr>
<tr class="separator:a15a385b1549cfec52bd5d4dfa141ac92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55caf338ff53cd621cd822b654fc78a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a55caf338ff53cd621cd822b654fc78a3">Sample</a> (size_t _numNodes, size_t _maxAttempts, const <a class="el" href="classSamplerMethod.html#a84f6944c978c28770334f8d519c18d9f">BoundaryMap</a> &amp;_boundary, <a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a> _valid, <a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a> _invalid)</td></tr>
<tr class="separator:a55caf338ff53cd621cd822b654fc78a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fad6b023615cd5bc5fcb79b427c6c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a55fad6b023615cd5bc5fcb79b427c6c4">Sample</a> (size_t _numNodes, size_t _maxAttempts, const <a class="el" href="classSamplerMethod.html#a84f6944c978c28770334f8d519c18d9f">BoundaryMap</a> &amp;_boundary, <a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a> _valid)</td></tr>
<tr class="separator:a55fad6b023615cd5bc5fcb79b427c6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96765b4b33ba1f2cf164a8ae1d3a352"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#aa96765b4b33ba1f2cf164a8ae1d3a352">Filter</a> (<a class="el" href="classSamplerMethod.html#a5d655628d748e2ea08d813a3d73bd4c0">GroupInputIterator</a> _first, <a class="el" href="classSamplerMethod.html#a5d655628d748e2ea08d813a3d73bd4c0">GroupInputIterator</a> _last, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, <a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a> _valid, <a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a> _invalid)</td></tr>
<tr class="separator:aa96765b4b33ba1f2cf164a8ae1d3a352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc111c9b7a0ba55fb0408c743be04665"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#adc111c9b7a0ba55fb0408c743be04665">Filter</a> (<a class="el" href="classSamplerMethod.html#a5d655628d748e2ea08d813a3d73bd4c0">GroupInputIterator</a> _first, <a class="el" href="classSamplerMethod.html#a5d655628d748e2ea08d813a3d73bd4c0">GroupInputIterator</a> _last, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, <a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a> _valid)</td></tr>
<tr class="memdesc:adc111c9b7a0ba55fb0408c743be04665"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classSamplerMethod.html#adc111c9b7a0ba55fb0408c743be04665">More...</a><br /></td></tr>
<tr class="separator:adc111c9b7a0ba55fb0408c743be04665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classMPBaseObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classMPBaseObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classMPBaseObject.html">MPBaseObject</a></td></tr>
<tr class="memitem:aa2708cce0ac2268d85f267e3b5ef6f75 inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#aa2708cce0ac2268d85f267e3b5ef6f75">MPBaseObject</a> (const std::string &amp;_label=&quot;&quot;, const std::string &amp;_name=&quot;&quot;, bool _debug=false)</td></tr>
<tr class="separator:aa2708cce0ac2268d85f267e3b5ef6f75 inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4763406edae04123c8bbf88552262c inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#adc4763406edae04123c8bbf88552262c">MPBaseObject</a> (<a class="el" href="classXMLNode.html">XMLNode</a> &amp;_node)</td></tr>
<tr class="separator:adc4763406edae04123c8bbf88552262c inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934cee21460217e9ee749be04daa43ca inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a934cee21460217e9ee749be04daa43ca">~MPBaseObject</a> ()</td></tr>
<tr class="separator:a934cee21460217e9ee749be04daa43ca inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c77bcfd6bee0270a1fa769325be7c20 inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a2c77bcfd6bee0270a1fa769325be7c20">Print</a> (std::ostream &amp;_os) const</td></tr>
<tr class="separator:a2c77bcfd6bee0270a1fa769325be7c20 inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4ca9ff414d5e534de09475cd101154 inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a5d4ca9ff414d5e534de09475cd101154">Initialize</a> ()</td></tr>
<tr class="separator:a5d4ca9ff414d5e534de09475cd101154 inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558b2ecf6fa413c62cfe962f86931bb0 inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a558b2ecf6fa413c62cfe962f86931bb0">GetName</a> () const</td></tr>
<tr class="memdesc:a558b2ecf6fa413c62cfe962f86931bb0 inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the class name for this object.  <a href="classMPBaseObject.html#a558b2ecf6fa413c62cfe962f86931bb0">More...</a><br /></td></tr>
<tr class="separator:a558b2ecf6fa413c62cfe962f86931bb0 inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d9d52b0645e52f2b2c4c60ca35da23 inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a09d9d52b0645e52f2b2c4c60ca35da23">GetLabel</a> () const</td></tr>
<tr class="memdesc:a09d9d52b0645e52f2b2c4c60ca35da23 inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique label for this object.  <a href="classMPBaseObject.html#a09d9d52b0645e52f2b2c4c60ca35da23">More...</a><br /></td></tr>
<tr class="separator:a09d9d52b0645e52f2b2c4c60ca35da23 inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b157f30833aa474087e148589bf5e22 inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a2b157f30833aa474087e148589bf5e22">GetNameAndLabel</a> () const</td></tr>
<tr class="memdesc:a2b157f30833aa474087e148589bf5e22 inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique string identifier for this object "m_name::m_label".  <a href="classMPBaseObject.html#a2b157f30833aa474087e148589bf5e22">More...</a><br /></td></tr>
<tr class="separator:a2b157f30833aa474087e148589bf5e22 inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77356657dd763bee634d8a0471481f2d inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a77356657dd763bee634d8a0471481f2d">SetLabel</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a77356657dd763bee634d8a0471481f2d inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the unique label for this object.  <a href="classMPBaseObject.html#a77356657dd763bee634d8a0471481f2d">More...</a><br /></td></tr>
<tr class="separator:a77356657dd763bee634d8a0471481f2d inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592f29cfa73851e9a58e38f57a4b8320 inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a592f29cfa73851e9a58e38f57a4b8320">SetMPLibrary</a> (<a class="el" href="classMPLibrary.html">MPLibrary</a> *) noexcept</td></tr>
<tr class="memdesc:a592f29cfa73851e9a58e38f57a4b8320 inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the owning <a class="el" href="classMPLibrary.html">MPLibrary</a>.  <a href="classMPBaseObject.html#a592f29cfa73851e9a58e38f57a4b8320">More...</a><br /></td></tr>
<tr class="separator:a592f29cfa73851e9a58e38f57a4b8320 inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acf803bf6c3b104dd6e6e786d91717a inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPLibrary.html">MPLibrary</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a5acf803bf6c3b104dd6e6e786d91717a">GetMPLibrary</a> () const noexcept</td></tr>
<tr class="memdesc:a5acf803bf6c3b104dd6e6e786d91717a inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the owning <a class="el" href="classMPLibrary.html">MPLibrary</a>.  <a href="classMPBaseObject.html#a5acf803bf6c3b104dd6e6e786d91717a">More...</a><br /></td></tr>
<tr class="separator:a5acf803bf6c3b104dd6e6e786d91717a inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d98c486c75d70ad376235e79cb44f5 inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a52d98c486c75d70ad376235e79cb44f5">IsRunning</a> () const noexcept</td></tr>
<tr class="memdesc:a52d98c486c75d70ad376235e79cb44f5 inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the library's running flag.  <a href="classMPBaseObject.html#a52d98c486c75d70ad376235e79cb44f5">More...</a><br /></td></tr>
<tr class="separator:a52d98c486c75d70ad376235e79cb44f5 inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932da44c88897bfd523666d0399380d8 inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPProblem.html">MPProblem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a932da44c88897bfd523666d0399380d8">GetMPProblem</a> () const noexcept</td></tr>
<tr class="memdesc:a932da44c88897bfd523666d0399380d8 inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the library's current <a class="el" href="classMPProblem.html">MPProblem</a>.  <a href="classMPBaseObject.html#a932da44c88897bfd523666d0399380d8">More...</a><br /></td></tr>
<tr class="separator:a932da44c88897bfd523666d0399380d8 inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5dcc061d806577d532ba3af66200a2d inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEnvironment.html">Environment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#ad5dcc061d806577d532ba3af66200a2d">GetEnvironment</a> () const noexcept</td></tr>
<tr class="memdesc:ad5dcc061d806577d532ba3af66200a2d inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current environment.  <a href="classMPBaseObject.html#ad5dcc061d806577d532ba3af66200a2d">More...</a><br /></td></tr>
<tr class="separator:ad5dcc061d806577d532ba3af66200a2d inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab307334bc71d1dcf11342269f078eac1 inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPTask.html">MPTask</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#ab307334bc71d1dcf11342269f078eac1">GetTask</a> () const noexcept</td></tr>
<tr class="memdesc:ab307334bc71d1dcf11342269f078eac1 inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current task.  <a href="classMPBaseObject.html#ab307334bc71d1dcf11342269f078eac1">More...</a><br /></td></tr>
<tr class="separator:ab307334bc71d1dcf11342269f078eac1 inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63ee9f0d8ff9e328fcdea583d77c8cf inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGroupTask.html">GroupTask</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#aa63ee9f0d8ff9e328fcdea583d77c8cf">GetGroupTask</a> () const noexcept</td></tr>
<tr class="memdesc:aa63ee9f0d8ff9e328fcdea583d77c8cf inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current group task.  <a href="classMPBaseObject.html#aa63ee9f0d8ff9e328fcdea583d77c8cf">More...</a><br /></td></tr>
<tr class="separator:aa63ee9f0d8ff9e328fcdea583d77c8cf inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326ab667c0b568c9439b270c968ae8aa inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPSolutionType.html">MPSolutionType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a326ab667c0b568c9439b270c968ae8aa">GetMPSolution</a> () const noexcept</td></tr>
<tr class="separator:a326ab667c0b568c9439b270c968ae8aa inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbcaf43d2a3cdf47256d66d49b8e605 inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPBaseObject.html#a1cb9a08003cc7620b1534bdf69ceb1a4">RoadmapType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a8fbcaf43d2a3cdf47256d66d49b8e605">GetRoadmap</a> (<a class="el" href="classRobot.html">Robot</a> *const _r=nullptr) const noexcept</td></tr>
<tr class="memdesc:a8fbcaf43d2a3cdf47256d66d49b8e605 inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current free-space roadmap.  <a href="classMPBaseObject.html#a8fbcaf43d2a3cdf47256d66d49b8e605">More...</a><br /></td></tr>
<tr class="separator:a8fbcaf43d2a3cdf47256d66d49b8e605 inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afa7f1c1885544859f84f5ca3148fdd inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPBaseObject.html#a062f6026973104069b7e08eb23a890f7">GroupRoadmapType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a2afa7f1c1885544859f84f5ca3148fdd">GetGroupRoadmap</a> (<a class="el" href="classRobotGroup.html">RobotGroup</a> *const _g=nullptr) const noexcept</td></tr>
<tr class="memdesc:a2afa7f1c1885544859f84f5ca3148fdd inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current free-space group roadmap.  <a href="classMPBaseObject.html#a2afa7f1c1885544859f84f5ca3148fdd">More...</a><br /></td></tr>
<tr class="separator:a2afa7f1c1885544859f84f5ca3148fdd inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada7dc60e619e7b9b43f15af99d498b5 inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPBaseObject.html#a1cb9a08003cc7620b1534bdf69ceb1a4">RoadmapType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#aada7dc60e619e7b9b43f15af99d498b5">GetBlockRoadmap</a> (<a class="el" href="classRobot.html">Robot</a> *const _r=nullptr) const noexcept</td></tr>
<tr class="memdesc:aada7dc60e619e7b9b43f15af99d498b5 inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current obstacle-space roadmap.  <a href="classMPBaseObject.html#aada7dc60e619e7b9b43f15af99d498b5">More...</a><br /></td></tr>
<tr class="separator:aada7dc60e619e7b9b43f15af99d498b5 inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62dc6d67728f7047afd1ec70f8e675f1 inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPath.html">Path</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a62dc6d67728f7047afd1ec70f8e675f1">GetPath</a> (<a class="el" href="classRobot.html">Robot</a> *const _r=nullptr) const noexcept</td></tr>
<tr class="separator:a62dc6d67728f7047afd1ec70f8e675f1 inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283e10c17ea82cf54ad2baf3c1785d6b inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGroupPath.html">GroupPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a283e10c17ea82cf54ad2baf3c1785d6b">GetGroupPath</a> (<a class="el" href="classRobotGroup.html">RobotGroup</a> *const _g=nullptr) const noexcept</td></tr>
<tr class="memdesc:a283e10c17ea82cf54ad2baf3c1785d6b inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current best group path.  <a href="classMPBaseObject.html#a283e10c17ea82cf54ad2baf3c1785d6b">More...</a><br /></td></tr>
<tr class="separator:a283e10c17ea82cf54ad2baf3c1785d6b inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c845feb2a9a84b8b1d1a8fddd945365 inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStatClass.html">StatClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a4c845feb2a9a84b8b1d1a8fddd945365">GetStatClass</a> () const noexcept</td></tr>
<tr class="memdesc:a4c845feb2a9a84b8b1d1a8fddd945365 inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current <a class="el" href="classStatClass.html">StatClass</a>.  <a href="classMPBaseObject.html#a4c845feb2a9a84b8b1d1a8fddd945365">More...</a><br /></td></tr>
<tr class="separator:a4c845feb2a9a84b8b1d1a8fddd945365 inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302e33446886aa07a7b7b3277672ce2d inherit pub_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLocalObstacleMap.html">LocalObstacleMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a302e33446886aa07a7b7b3277672ce2d">GetLocalObstacleMap</a> () const noexcept</td></tr>
<tr class="memdesc:a302e33446886aa07a7b7b3277672ce2d inherit pub_methods_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local obstacle map.  <a href="classMPBaseObject.html#a302e33446886aa07a7b7b3277672ce2d">More...</a><br /></td></tr>
<tr class="separator:a302e33446886aa07a7b7b3277672ce2d inherit pub_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Sampler Rule</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The default implementations of these throw exceptions so that derived classes can avoid implementing unsupported functions (as opposed to making these pure virtual). </p>
</div></td></tr>
<tr class="memitem:a99391d525a01e8cb69ae3ce7fe4ac2a6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a99391d525a01e8cb69ae3ce7fe4ac2a6">Sampler</a> (<a class="el" href="classCfg.html">Cfg</a> &amp;_cfg, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, std::vector&lt; <a class="el" href="classCfg.html">Cfg</a> &gt; &amp;_valid, std::vector&lt; <a class="el" href="classCfg.html">Cfg</a> &gt; &amp;_invalid)</td></tr>
<tr class="separator:a99391d525a01e8cb69ae3ce7fe4ac2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c0e0ff3607ffe1bfe3c61f1d16ed6e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a53c0e0ff3607ffe1bfe3c61f1d16ed6e">Sampler</a> (<a class="el" href="classCfg.html">Cfg</a> &amp;_cfg, const <a class="el" href="classBoundary.html">Boundary</a> *const _robotBoundary, const <a class="el" href="classBoundary.html">Boundary</a> *const _eeBoundary, std::vector&lt; <a class="el" href="classCfg.html">Cfg</a> &gt; &amp;_valid, std::vector&lt; <a class="el" href="classCfg.html">Cfg</a> &gt; &amp;_invalid)</td></tr>
<tr class="separator:a53c0e0ff3607ffe1bfe3c61f1d16ed6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a546ad33b419913e2202c8da4c8e48"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#ad5a546ad33b419913e2202c8da4c8e48">Sampler</a> (<a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a> &amp;_cfg, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, std::vector&lt; <a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a> &gt; &amp;_valid, std::vector&lt; <a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a> &gt; &amp;_invalid)</td></tr>
<tr class="separator:ad5a546ad33b419913e2202c8da4c8e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02474f069a08d32d512d25e9a60cf683"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a02474f069a08d32d512d25e9a60cf683">Sampler</a> (<a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a> &amp;_cfg, const <a class="el" href="classSamplerMethod.html#a84f6944c978c28770334f8d519c18d9f">BoundaryMap</a> &amp;_boundaryMap, std::vector&lt; <a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a> &gt; &amp;_valid, std::vector&lt; <a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a> &gt; &amp;_invalid)</td></tr>
<tr class="separator:a02474f069a08d32d512d25e9a60cf683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classMPBaseObject"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classMPBaseObject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classMPBaseObject.html">MPBaseObject</a></td></tr>
<tr class="memitem:af6aea751544b43f86b371ce432a05724 inherit pro_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#af6aea751544b43f86b371ce432a05724">SetName</a> (const std::string &amp;_s)</td></tr>
<tr class="separator:af6aea751544b43f86b371ce432a05724 inherit pro_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c656603839bf545bd53e7567c1fc59e inherit pro_methods_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a5c656603839bf545bd53e7567c1fc59e">GetBaseFilename</a> () const</td></tr>
<tr class="separator:a5c656603839bf545bd53e7567c1fc59e inherit pro_methods_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a709894064dc87de1d3016b6f177654b4"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a709894064dc87de1d3016b6f177654b4">MixSampler</a></td></tr>
<tr class="separator:a709894064dc87de1d3016b6f177654b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classMPBaseObject"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classMPBaseObject')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classMPBaseObject.html">MPBaseObject</a></td></tr>
<tr class="memitem:a69f05ccf2fb3c91a2747dfd0afb385a2 inherit pro_attribs_classMPBaseObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a69f05ccf2fb3c91a2747dfd0afb385a2">m_debug</a></td></tr>
<tr class="memdesc:a69f05ccf2fb3c91a2747dfd0afb385a2 inherit pro_attribs_classMPBaseObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print debug info?  <a href="classMPBaseObject.html#a69f05ccf2fb3c91a2747dfd0afb385a2">More...</a><br /></td></tr>
<tr class="separator:a69f05ccf2fb3c91a2747dfd0afb385a2 inherit pro_attribs_classMPBaseObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base algorithm abstraction for Samplers.</p>
<p><a class="el" href="classSamplerMethod.html">SamplerMethod</a> has three sets of important functions. The first two are the various public methods in the base class, <code>Sample</code> and <code>Filter</code>, and third is the private virtual function which the derived classes overload, <code>Sampler</code>.</p>
<p><code>Sample</code> is called in various ways but they break down into two forms: desired number and input configurations. When specifying a desired number <code>n</code> of configurations the sampler attempts <code>a</code> attempts per desired sample. The output is placed on an output iterator.</p>
<p>@usage </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> num, attempts;</div>
<div class="line"><a class="code" href="classBoundary.html">Boundary</a>* bounds;</div>
<div class="line">std::vector&lt;Cfg&gt; valid;</div>
<div class="line"><span class="keyword">auto</span> s = this-&gt;GetSampler(m_sLabel);</div>
<div class="line">s-&gt;Sample(num, attempts, bounds, std::back_inserter(valid));</div>
<div class="ttc" id="aclassBoundary_html"><div class="ttname"><a href="classBoundary.html">Boundary</a></div><div class="ttdef"><b>Definition:</b> Boundary.h:30</div></div>
</div><!-- fragment --><p><code>Filter</code> sends a list of input configurations to apply the sampler rule to.</p>
<p>@usage </p><div class="fragment"><div class="line">std::vector&lt;Cfg&gt; input, valid;</div>
<div class="line"><span class="keywordtype">size_t</span> attempts;</div>
<div class="line"><a class="code" href="classBoundary.html">Boundary</a>* bounds;</div>
<div class="line"><span class="keyword">auto</span> s = this-&gt;GetSampler(m_sLabel);</div>
<div class="line">s-&gt;Filter(input.begin(), input.end(), attempts, bounds,</div>
<div class="line">    std::back_inserter(valid));</div>
</div><!-- fragment --><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000064">Todo:</a></b></dt><dd>The present implementation of Sample temporarily saves invalid configurations whether we will use them or not. Avoiding this extraneous retention will likely have good performance benefits in sampling-intensive applications such as proteins and manipulators where the success rate is very low.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000065">Todo:</a></b></dt><dd>The present layout of this class is confusing since the base method is actually generating uniform random samples which are filtered by the derived class. This does not work for many derived classes as evidenced by their overriding of Sample rather than Sampler: we should rework the design so that derived classes generate and filter their own samples. The base class can then implement its functions in terms of the generate and filter helpers.</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Samplers_UseCase_8cpp-example.html#_a0">Samplers_UseCase.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a84f6944c978c28770334f8d519c18d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f6944c978c28770334f8d519c18d9f">&#9670;&nbsp;</a></span>BoundaryMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="classRobot.html">Robot</a>*, const <a class="el" href="classBoundary.html">Boundary</a>*&gt; <a class="el" href="classSamplerMethod.html#a84f6944c978c28770334f8d519c18d9f">SamplerMethod::BoundaryMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map from robots to sampling boundaries. </p>

</div>
</div>
<a id="a4d2315534d97771e3f262573054a64be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2315534d97771e3f262573054a64be">&#9670;&nbsp;</a></span>GroupCfgType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">MPBaseObject::GroupCfgType</a> <a class="el" href="classSamplerMethod.html#a4d2315534d97771e3f262573054a64be">SamplerMethod::GroupCfgType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d655628d748e2ea08d813a3d73bd4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d655628d748e2ea08d813a3d73bd4c0">&#9670;&nbsp;</a></span>GroupInputIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a>&gt;::iterator <a class="el" href="classSamplerMethod.html#a5d655628d748e2ea08d813a3d73bd4c0">SamplerMethod::GroupInputIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad47218ae4716273df3d40038e0396db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47218ae4716273df3d40038e0396db9">&#9670;&nbsp;</a></span>GroupOutputIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::back_insert_iterator&lt;std::vector&lt;<a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a>&gt; &gt; <a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">SamplerMethod::GroupOutputIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a914d9dc5ae04bf467c3116c058da0757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914d9dc5ae04bf467c3116c058da0757">&#9670;&nbsp;</a></span>InputIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classCfg.html">Cfg</a>&gt;::iterator <a class="el" href="classSamplerMethod.html#a914d9dc5ae04bf467c3116c058da0757">SamplerMethod::InputIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87095150c507a033d88a8f3de99b70ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87095150c507a033d88a8f3de99b70ce">&#9670;&nbsp;</a></span>OutputIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::back_insert_iterator&lt;std::vector&lt;<a class="el" href="classCfg.html">Cfg</a>&gt; &gt; <a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">SamplerMethod::OutputIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a36bbf5f98d952b0feec38e4961eacb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bbf5f98d952b0feec38e4961eacb60">&#9670;&nbsp;</a></span>SamplerMethod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SamplerMethod::SamplerMethod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2048574fd46691a2fbadff23b5ac12c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2048574fd46691a2fbadff23b5ac12c2">&#9670;&nbsp;</a></span>SamplerMethod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SamplerMethod::SamplerMethod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXMLNode.html">XMLNode</a> &amp;&#160;</td>
          <td class="paramname"><em>_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7425beb78efe71a47f7086713ae9e681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7425beb78efe71a47f7086713ae9e681">&#9670;&nbsp;</a></span>~SamplerMethod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SamplerMethod::~SamplerMethod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adc111c9b7a0ba55fb0408c743be04665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc111c9b7a0ba55fb0408c743be04665">&#9670;&nbsp;</a></span>Filter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SamplerMethod::Filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a5d655628d748e2ea08d813a3d73bd4c0">GroupInputIterator</a>&#160;</td>
          <td class="paramname"><em>_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a5d655628d748e2ea08d813a3d73bd4c0">GroupInputIterator</a>&#160;</td>
          <td class="paramname"><em>_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a>&#160;</td>
          <td class="paramname"><em>_valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa96765b4b33ba1f2cf164a8ae1d3a352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96765b4b33ba1f2cf164a8ae1d3a352">&#9670;&nbsp;</a></span>Filter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SamplerMethod::Filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a5d655628d748e2ea08d813a3d73bd4c0">GroupInputIterator</a>&#160;</td>
          <td class="paramname"><em>_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a5d655628d748e2ea08d813a3d73bd4c0">GroupInputIterator</a>&#160;</td>
          <td class="paramname"><em>_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a>&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a>&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply the sampler rule to a set of existing configurations. The output will generally be a filtered or perturbed version of the input set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_first</td><td>An iterator to the beginning of a list of input configurations. </td></tr>
    <tr><td class="paramname">_last</td><td>An iterator to the end of a list of input configurations. </td></tr>
    <tr><td class="paramname">_maxAttempts</td><td>The maximum number of attempts to successfully apply the sampler rule to each input. </td></tr>
    <tr><td class="paramname">_boundary</td><td>The sampling boundary to use. </td></tr>
    <tr><td class="paramname">_valid</td><td>An iterator to storage for the output configurations. </td></tr>
    <tr><td class="paramname">_invalid</td><td>An (optional) iterator to storage for failed attempts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c939aa5b5f15b052ae10ee693c0d832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c939aa5b5f15b052ae10ee693c0d832">&#9670;&nbsp;</a></span>Filter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SamplerMethod::Filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a914d9dc5ae04bf467c3116c058da0757">InputIterator</a>&#160;</td>
          <td class="paramname"><em>_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a914d9dc5ae04bf467c3116c058da0757">InputIterator</a>&#160;</td>
          <td class="paramname"><em>_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a>&#160;</td>
          <td class="paramname"><em>_valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This version does not return invalid samples. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a8a2494b15fd4815d8d0aed9c2f1e21e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2494b15fd4815d8d0aed9c2f1e21e0">&#9670;&nbsp;</a></span>Filter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SamplerMethod::Filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a914d9dc5ae04bf467c3116c058da0757">InputIterator</a>&#160;</td>
          <td class="paramname"><em>_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a914d9dc5ae04bf467c3116c058da0757">InputIterator</a>&#160;</td>
          <td class="paramname"><em>_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a>&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a>&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply the sampler rule to a set of existing configurations. The output will generally be a filtered or perturbed version of the input set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_first</td><td>An iterator to the beginning of a list of input configurations. </td></tr>
    <tr><td class="paramname">_last</td><td>An iterator to the end of a list of input configurations. </td></tr>
    <tr><td class="paramname">_maxAttempts</td><td>The maximum number of attempts to successfully apply the sampler rule to each input. </td></tr>
    <tr><td class="paramname">_boundary</td><td>The sampling boundary to use. </td></tr>
    <tr><td class="paramname">_valid</td><td>An iterator to storage for the output configurations. </td></tr>
    <tr><td class="paramname">_invalid</td><td>An (optional) iterator to storage for failed attempts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Samplers_UseCase_8cpp-example.html#a3">Samplers_UseCase.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a15a385b1549cfec52bd5d4dfa141ac92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a385b1549cfec52bd5d4dfa141ac92">&#9670;&nbsp;</a></span>Sample() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SamplerMethod::Sample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a>&#160;</td>
          <td class="paramname"><em>_valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This version does not return invalid samples. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ad0a233df53eadb9e0b3dfdda54022cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a233df53eadb9e0b3dfdda54022cc6">&#9670;&nbsp;</a></span>Sample() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SamplerMethod::Sample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a>&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a>&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Try to sample a set number of new configurations from a single boundary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_numNodes</td><td>The number of samples desired. </td></tr>
    <tr><td class="paramname">_maxAttempts</td><td>The maximum number of attempts for each sample. </td></tr>
    <tr><td class="paramname">_boundary</td><td>The boundary to sample from. </td></tr>
    <tr><td class="paramname">_valid</td><td>An iterator to storage for the new configurations. </td></tr>
    <tr><td class="paramname">_invalid</td><td>An (optional) iterator to storage for failed attempts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad83a1674031e57439b6a01f2c80cbdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83a1674031e57439b6a01f2c80cbdf6">&#9670;&nbsp;</a></span>Sample() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SamplerMethod::Sample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a>&#160;</td>
          <td class="paramname"><em>_valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a93f731d73ed5f838737e450b07031e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f731d73ed5f838737e450b07031e2c">&#9670;&nbsp;</a></span>Sample() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SamplerMethod::Sample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a>&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a>&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Try to sample a set number of new configurations from a given boundary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_numNodes</td><td>The number of samples desired. </td></tr>
    <tr><td class="paramname">_maxAttempts</td><td>The maximum number of attempts for each sample. </td></tr>
    <tr><td class="paramname">_boundary</td><td>The boundary to sample from. </td></tr>
    <tr><td class="paramname">_valid</td><td>An iterator to storage for the new configurations. </td></tr>
    <tr><td class="paramname">_invalid</td><td>An (optional) iterator to storage for failed attempts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Samplers_UseCase_8cpp-example.html#a2">Samplers_UseCase.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8d1999e4f3b7ec4b70cf68e4581ca480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1999e4f3b7ec4b70cf68e4581ca480">&#9670;&nbsp;</a></span>Sample() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SamplerMethod::Sample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_robotBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_eeBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a>&#160;</td>
          <td class="paramname"><em>_valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This version does not return invalid samples. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a8345e3a12f62693cc8e72f5a63528117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8345e3a12f62693cc8e72f5a63528117">&#9670;&nbsp;</a></span>Sample() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SamplerMethod::Sample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_robotBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_eeBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a>&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#a87095150c507a033d88a8f3de99b70ce">OutputIterator</a>&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Try to sample a set number of new configurations from a given boundary (for the entire robot), and additionally satisfying a constraint boundary for the end-effector (robot is presumed to have only one EE). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_robotBoundary</td><td>The boundary for the entire robot. </td></tr>
    <tr><td class="paramname">_eeBoundary</td><td>The boundary for the end-effector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55fad6b023615cd5bc5fcb79b427c6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55fad6b023615cd5bc5fcb79b427c6c4">&#9670;&nbsp;</a></span>Sample() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SamplerMethod::Sample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSamplerMethod.html#a84f6944c978c28770334f8d519c18d9f">BoundaryMap</a> &amp;&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a>&#160;</td>
          <td class="paramname"><em>_valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This version does not return invalid samples. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a55caf338ff53cd621cd822b654fc78a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55caf338ff53cd621cd822b654fc78a3">&#9670;&nbsp;</a></span>Sample() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SamplerMethod::Sample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSamplerMethod.html#a84f6944c978c28770334f8d519c18d9f">BoundaryMap</a> &amp;&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a>&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSamplerMethod.html#ad47218ae4716273df3d40038e0396db9">GroupOutputIterator</a>&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Try to sample a set number of new configurations from a boundary for each robot. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_numNodes</td><td>The number of samples desired. </td></tr>
    <tr><td class="paramname">_maxAttempts</td><td>The maximum number of attempts for each sample. </td></tr>
    <tr><td class="paramname">_boundaryMap</td><td>A map from robot to sampling boundary. Any robots which are not found in the map will use the environment boundary. </td></tr>
    <tr><td class="paramname">_valid</td><td>An iterator to storage for the new configurations. </td></tr>
    <tr><td class="paramname">_invalid</td><td>An (optional) iterator to storage for failed attempts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99391d525a01e8cb69ae3ce7fe4ac2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99391d525a01e8cb69ae3ce7fe4ac2a6">&#9670;&nbsp;</a></span>Sampler() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SamplerMethod::Sampler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCfg.html">Cfg</a> &amp;&#160;</td>
          <td class="paramname"><em>_cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classCfg.html">Cfg</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classCfg.html">Cfg</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes a single input configuration and applies the sampler rule to generate one or more output configurations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cfg</td><td>The input configuration. </td></tr>
    <tr><td class="paramname">_boundary</td><td>The sampling boundary. </td></tr>
    <tr><td class="paramname">_valid</td><td>The resulting output configurations. </td></tr>
    <tr><td class="paramname">_invalid</td><td>The (optional) return for failed attempts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a valid configuration was generated, false otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classBridgeTestSampler.html#af3f4ed140e40b860bf96d335a75d63f1">BridgeTestSampler</a>, <a class="el" href="classMixSampler.html#a8ad152189903216e1dae2097dd22538b">MixSampler</a>, <a class="el" href="classGaussianSampler.html#ab3e47fe59b6ac768c252d2e9adacef4e">GaussianSampler</a>, <a class="el" href="classUniformRandomSampler.html#a0c60d940c122b41645683e414b7ff9d8">UniformRandomSampler</a>, <a class="el" href="classUniformObstacleBasedSampler.html#a784c8e3f2f4f214adc7b623749ad4d00">UniformObstacleBasedSampler</a>, and <a class="el" href="classObstacleBasedSampler.html#a045258976012b21f59471ae64ee9f2a2">ObstacleBasedSampler</a>.</p>

</div>
</div>
<a id="a53c0e0ff3607ffe1bfe3c61f1d16ed6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c0e0ff3607ffe1bfe3c61f1d16ed6e">&#9670;&nbsp;</a></span>Sampler() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SamplerMethod::Sampler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCfg.html">Cfg</a> &amp;&#160;</td>
          <td class="paramname"><em>_cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_robotBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_eeBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classCfg.html">Cfg</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classCfg.html">Cfg</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This version also specifies a boundary for the end-effector. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ad5a546ad33b419913e2202c8da4c8e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a546ad33b419913e2202c8da4c8e48">&#9670;&nbsp;</a></span>Sampler() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SamplerMethod::Sampler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a> &amp;&#160;</td>
          <td class="paramname"><em>_cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes a single input configuration and applies the sampler rule to generate one or more output configurations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cfg</td><td>The input group configuration. </td></tr>
    <tr><td class="paramname">_boundary</td><td>The sampling boundary. </td></tr>
    <tr><td class="paramname">_valid</td><td>The resulting output configurations. </td></tr>
    <tr><td class="paramname">_invalid</td><td>The (optional) return for failed attempts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a valid configuration was generated, false otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classBridgeTestSampler.html#ae688c2420754b148791201ba39c08bd5">BridgeTestSampler</a>, <a class="el" href="classUniformRandomSampler.html#a41936ce1cda98c5477084ae95e4eb328">UniformRandomSampler</a>, <a class="el" href="classUniformObstacleBasedSampler.html#ac82873e9b116136307969af2c32fe398">UniformObstacleBasedSampler</a>, and <a class="el" href="classObstacleBasedSampler.html#a3527d451aefed76964a253a206785021">ObstacleBasedSampler</a>.</p>

</div>
</div>
<a id="a02474f069a08d32d512d25e9a60cf683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02474f069a08d32d512d25e9a60cf683">&#9670;&nbsp;</a></span>Sampler() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SamplerMethod::Sampler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a> &amp;&#160;</td>
          <td class="paramname"><em>_cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSamplerMethod.html#a84f6944c978c28770334f8d519c18d9f">BoundaryMap</a> &amp;&#160;</td>
          <td class="paramname"><em>_boundaryMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMPBaseObject.html#aad3c1d1dccb02cfd48da4438a2b2923b">GroupCfgType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This version specifies a (possibly different) boundary for each robot. Robots which are not in the boundary map will use the environment boundary. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Reimplemented in <a class="el" href="classUniformRandomSampler.html#abcb60cf8f925ffcb4e7caabd5dba8870">UniformRandomSampler</a>, <a class="el" href="classBridgeTestSampler.html#aa903d8b71f6f1e4f2a074f27602cee5f">BridgeTestSampler</a>, and <a class="el" href="classObstacleBasedSampler.html#ae14b645b208c464ec8f3de3bca9b334f">ObstacleBasedSampler</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a709894064dc87de1d3016b6f177654b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709894064dc87de1d3016b6f177654b4">&#9670;&nbsp;</a></span>MixSampler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classMixSampler.html">MixSampler</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/opt/actions-runner/_work/open-ppl/open-ppl/src/MPLibrary/Samplers/<a class="el" href="SamplerMethod_8h_source.html">SamplerMethod.h</a></li>
<li>/opt/actions-runner/_work/open-ppl/open-ppl/src/MPLibrary/Samplers/<a class="el" href="SamplerMethod_8cpp.html">SamplerMethod.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
