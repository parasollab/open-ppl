/*
// Copyright (c) 2000-2009, Texas Engineering Experiment Station (TEES), a
// component of the Texas A&M University System.

// All rights reserved.

// The information and source code contained herein is the exclusive
// property of TEES and may not be disclosed, examined or reproduced
// in whole or in part without explicit written authorization from TEES.
*/

#include <cstdlib>
#include <iostream>
#include <stapl/array.hpp>
#include <stapl/algorithm.hpp>
#include <test/confint.hpp>


typedef long long long_type;

using namespace stapl;

//////////////////////////////////////////////////////////////////////
/// @brief A Collatz sequence is generated by the following rule:
///   n -> n/2 (n is even)
///   n -> 3n + 1 (n is odd)
/// This is the work function that maps each number to the length of
/// its Collatz sequence.
//////////////////////////////////////////////////////////////////////
struct collatz_map
{
  template<typename T>
  T operator()(T num)
  {
    long_type length = 1;
    while (num != 1) {
      if (num%2) {
        num = 3*num+1;
      } else {
        num = num/2;
      }
      length++;
    }
    num = length;
    return num;
  }
};


//////////////////////////////////////////////////////////////////////
/// @brief Work function that looks for the longest Collatz sequence.
//////////////////////////////////////////////////////////////////////
struct collatz_reduce
{
  template<typename T>
  T operator()(T ref1, T ref2) const
  {
    return ref1 > ref2 ? ref1 : ref2;
  }
};


//////////////////////////////////////////////////////////////////////
/// @brief This is the work function that inserts the first half of
///   the numbers to elements with even index and reversely insert
///   the second half to elements with odd index.
///   ex: 1 20 2 19 3 18 4 17 5 16 6 15 7 14 8 13 9 12 10 11
//////////////////////////////////////////////////////////////////////
struct fill_view_mingle
{
  /// The size of input data
  long_type m_size;

  fill_view_mingle(long_type s)
    : m_size(s)
  {}

  template<typename Ref>
  void operator()(Ref ref)
  {
    long_type index = index_of(ref);
    if (index%2) {
      ref = m_size - index/2;
    } else {
      ref = index/2 + 1;
    }
  }

  void define_type(stapl::typer& t)
  {
    t.member(m_size);
  }
};


//////////////////////////////////////////////////////////////////////
/// @brief This is the work function that insert input numbers at
///   certain interval.
///   ex: 1 5 9 13 17 2 6 10 14 18 3 7 11 15 19 4 8 12 16 20
///       (interval = 5)
//////////////////////////////////////////////////////////////////////
struct fill_view_interval
{
  /// The size of input data
  long_type m_size;

  /// The interval between consecutive input numbers
  long_type m_inter;

  fill_view_interval(long_type s, long_type i)
    : m_size(s), m_inter(i)
  {}

  template<typename Ref>
  void operator()(Ref ref)
  {
    long_type index = index_of(ref);
    long_type offset = index%m_inter - m_size%m_inter;
    offset = offset > 0 ? offset : 0;
    ref = index/m_inter + (m_size+m_inter)/m_inter*(index%m_inter) + 1
        - offset;
  }

  void define_type(stapl::typer& t)
  {
    t.member(m_size);
    t.member(m_inter);
  }
};


exit_code stapl_main(int argc, char** argv)
{
  if ((argc == 3 and atol(argv[2]) == 2) or argc < 3) {
    do_once ([&] {
      std::cout << "Usage: pe_14 [n] [fill pattern] [interval]" << std::endl;
      std::cout << std::endl;
      std::cout << "* For \"fill pattern\" please input: " << std::endl;
      std::cout << "* 0 for linear, 1 for mingle, 2 for interval" << std::endl;
      std::cout << "* If interval pattern is selected, " << std::endl;
      std::cout << "* please also specify the interval." << std::endl;
    });
    return EXIT_SUCCESS;
  }

  long_type size = atol(argv[1]);
  long_type fill_pt = atol(argv[2]);

  // Create array container and its view for input numbers.
  array<long_type> num_arr(size);
  array_view<array<long_type>> num_vw(num_arr);

  // Create container and view to store Collatz sequence length.
  array<long_type> cslen_arr(size);
  array_view<array<long_type>> cslen_vw(cslen_arr);

  // Fill the array based on user's selection
  switch (fill_pt) {
    case 0: {
      iota(num_vw, 1);
      break;
    } case 1: {
      map_func(fill_view_mingle(size), num_vw);
      break;
    } case 2: {
      map_func(fill_view_interval(size, atol(argv[3])), num_vw);
      break;
    }
  }

  // Declare and start a controller of timer to measure the execution time.
  counter<default_timer> timer;
  confidence_interval_controller ctrl(32, 32, 0.05);
  srand(time(NULL));

  // Run map_reduce 32 times to test the average performance.
  while (ctrl.iterate()) {
    copy(num_vw, cslen_vw);
    timer.start();

    // Call map_reduce with work functions to compute the Collatz sequence
    //   lengths and find the longest.
    map_reduce(
      collatz_map(), collatz_reduce(), cslen_vw);

    timer.stop();
    ctrl.push_back(timer.value());
    timer.reset();
  }

  // Get the reference to the maximum Collatz sequence length.
  // The result is the same as the result from the map_reduce above.
  auto max = max_element(cslen_vw);

  // Print out the result.
  do_once ([&] {
    std::cout << "Initial value: " << num_vw[index_of(max)] << std::endl;
    std::cout << "Max Collatz sequence length: " << max << std::endl;
  });

  ctrl.report("pe_14");

  return EXIT_SUCCESS;
}
