/*
// Copyright (c) 2000-2009, Texas Engineering Experiment Station (TEES), a
// component of the Texas A&M University System.

// All rights reserved.

// The information and source code contained herein is the exclusive
// property of TEES and may not be disclosed, examined or reproduced
// in whole or in part without explicit written authorization from TEES.
*/


#ifndef STAPL_RUNTIME_CONTEXT_ID_HPP
#define STAPL_RUNTIME_CONTEXT_ID_HPP

#include "exception.hpp"
#include "full_location.hpp"
#include <functional>
#include <stapl/utility/hash_fwd.hpp>

namespace stapl {

namespace runtime {

//////////////////////////////////////////////////////////////////////
/// @brief Id for an execution context. It is associated with @ref context
///        object.
///
/// @ref context_id objects are unique in the system in the sense that two
/// different @ref context_id objects correspond to different execution
/// contexts.
///
/// The @ref context_id is a compact version of the request invocation list.
/// This list consists of all the location ids that participated in the chain
/// of requests. For example, a request from location 2 to location 3 that will
/// generate a request to location 0 has an invocation list of {2, 3, 0}.
///
/// It is clear that the invocation list would increase with every request that
/// was created as a result of another. In order to avoid this, only the
/// following is in a @ref context_id at the moment of its creation (when a
/// request is about to be sent):
/// -# originator of the first request,
/// -# source of the request,
/// -# destination of the request,
/// -# nesting level and
/// -# a magic number.
///
/// The magic number is automatically generated by the source when it is
/// detected that the context id information is not enough and can result in two
/// unrelated requests generating the same context id. This can only happen when
/// the nesting level is more than 2.
///
/// The intragang flag is here to detect requests that went outside a gang and
/// generated requests that ended up in the same gang that the initiator is
/// from.
///
/// @see context
/// @ingroup runtimeMetadata
//////////////////////////////////////////////////////////////////////
struct context_id
{
  /// First location in invocation list.
  full_location initiator;
  /// Destination of the request.
  full_location current;
  /// Source of the request.
  full_location source;
  /// @c true if the invocation list has only locations of the same gang.
  bool          intragang;
  /// Nesting level of the request.
  nesting_level nesting;
  /// Number to disambiguate between two shortened invocation lists.
  magic_id      magic;

  //////////////////////////////////////////////////////////////////////
  /// @brief Creates an invalid @ref context_id object.
  //////////////////////////////////////////////////////////////////////
  constexpr context_id(void) noexcept
  : intragang(false),
    nesting(0),
    magic(0)
  { }

  //////////////////////////////////////////////////////////////////////
  /// @brief Creates a @ref context_id object for a base context.
  //////////////////////////////////////////////////////////////////////
  explicit context_id(full_location const& fl) noexcept
  : initiator(fl),
    current(fl),
    source(fl),
    intragang(true),
    nesting(0),
    magic(0)
  { STAPL_RUNTIME_ASSERT(current.valid()); }

  //////////////////////////////////////////////////////////////////////
  /// @brief Creates a @ref context_id object for point-to-point requests.
  //////////////////////////////////////////////////////////////////////
  context_id(full_location const& init,
             full_location const& current_loc,
             full_location const& source_loc,
             const bool intra_gang,
             const nesting_level n,
             const magic_id m) noexcept
  : initiator(init),
    current(current_loc),
    source(source_loc),
    intragang(intra_gang),
    nesting(n),
    magic(m)
  {
    STAPL_RUNTIME_ASSERT(initiator.valid() &&
                         current.valid()   &&
                         source.valid());
  }

  //////////////////////////////////////////////////////////////////////
  /// @brief Creates a @ref context_id object for broadcast and multicast
  ///        requests.
  //////////////////////////////////////////////////////////////////////
  context_id(full_location const& init,
             const gang_id gid,
             full_location const& source_loc,
             const bool intra_gang,
             const nesting_level n,
             const magic_id m) noexcept
  : initiator(init),
    current(full_location(gid)),
    source(source_loc),
    intragang(intra_gang),
    nesting(n),
    magic(m)
  {
    STAPL_RUNTIME_ASSERT(initiator.valid()                        &&
                         (current.get_gang_id()!=invalid_gang_id) &&
                         source.valid());
  }

  std::size_t hash_code(void) const noexcept
  {
    std::size_t seed = 0;
    boost::hash_combine(seed, initiator);
    boost::hash_combine(seed, current);
    boost::hash_combine(seed, source);
    boost::hash_combine(seed, intragang);
    boost::hash_combine(seed, nesting);
    boost::hash_combine(seed, magic);
    return seed;
  }
};


constexpr bool operator==(context_id const& x, context_id const& y) noexcept
{
  return ( (x.initiator == y.initiator) &&
           (x.current   == y.current)   &&
           (x.source    == y.source)    &&
           (x.intragang == y.intragang) &&
           (x.nesting   == y.nesting)   &&
           (x.magic     == y.magic) );
}

constexpr bool operator!=(context_id const& x, context_id const& y) noexcept
{
  return !(x==y);
}

inline bool operator<(context_id const& x, context_id const& y) noexcept
{
  if (x.initiator < y.initiator) return true;
  if (x.initiator > y.initiator) return false;
  if (x.current   < y.current)   return true;
  if (x.current   > y.current)   return false;
  if (x.source    < y.source)    return true;
  if (x.source    > y.source)    return false;
  if (x.nesting   < y.nesting)   return true;
  if (x.nesting   > y.nesting)   return false;
  if (x.intragang < y.intragang) return true;
  if (x.intragang > y.intragang) return false;
  return (x.magic < y.magic);
}


//////////////////////////////////////////////////////////////////////
/// @brief Hash value creation function for @ref context_id.
///
/// Required for @c boost::hash.
///
/// @related context_id
/// @ingroup runtimeMetadata
//////////////////////////////////////////////////////////////////////
inline std::size_t hash_value(context_id const& id) noexcept
{
  return id.hash_code();
}

} // namespace runtime

} // namespace stapl


namespace std {

//////////////////////////////////////////////////////////////////////
/// @brief Hash value creation functor for @ref stapl::runtime::context_id.
///
/// @related stapl::runtime::context_id
/// @ingroup runtimeMetadata
//////////////////////////////////////////////////////////////////////
template<>
struct hash<stapl::runtime::context_id>
{
  using argument_type = stapl::runtime::context_id;
  using result_type   = std::size_t;

  result_type operator()(argument_type const& t) const noexcept
  { return t.hash_code(); }
};

} // namespace std

#endif
