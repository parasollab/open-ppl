/*
// Copyright (c) 2000-2009, Texas Engineering Experiment Station (TEES), a
// component of the Texas A&M University System.

// All rights reserved.

// The information and source code contained herein is the exclusive
// property of TEES and may not be disclosed, examined or reproduced
// in whole or in part without explicit written authorization from TEES.
*/

#ifndef STAPL_SKELETONS_UTILITY_TAGS_HPP
#define STAPL_SKELETONS_UTILITY_TAGS_HPP

#include <stapl/utility/use_default.hpp>

namespace stapl {
namespace skeletons {
namespace tags {

//////////////////////////////////////////////////////////////////////
/// @ingroup skeletons
/// @defgroup skeletonsTags Skeleton Tags
/// @brief Tags are used to identify skeletons throughout the Skeletons
/// Framework. Identifying skeletons using their tags allows transformations
/// and optimizations to be simply defined over skeletons.
/// @{
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
/// @defgroup skeletonsTagsRepeat Repeat Operator Tags
/// @brief Sequence tags are used in customizing @c repeat flows
///
/// @see repeat_flows.hpp
/// @{
//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref repeat operator with single
/// iteration.
//////////////////////////////////////////////////////////////////////
struct repeat_single_iter {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify the first iteration of a @ref repeat
/// operator.
//////////////////////////////////////////////////////////////////////
struct repeat_first_iter {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify the iterations of a @ref repeat
/// operator except the first and last one.
//////////////////////////////////////////////////////////////////////
struct repeat_iter {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify the last iteration of a @ref repeat
/// operator.
//////////////////////////////////////////////////////////////////////
struct repeat_last_iter {};
/// @}

//////////////////////////////////////////////////////////////////////
/// @defgroup skeletonsTagsDoWhile Do-While Operator Tags
/// @brief Do-While tags are used in customizing @c do-while flows
///
/// @see do_while_flows.hpp
/// @{
//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify the first iteration of a @ref do-while
/// operator.
//////////////////////////////////////////////////////////////////////
struct while_first_iter {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify the iterations of a @ref do-while
/// operator.
//////////////////////////////////////////////////////////////////////
struct while_iteration {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify the last iteration of a @ref do-while
/// operator.
//////////////////////////////////////////////////////////////////////
struct while_last_iter {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify the reduction skeleton of a @ref do-while
/// operator.
//////////////////////////////////////////////////////////////////////
struct while_red {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify the continuation skeleton of a
/// @ref do-while operator.
//////////////////////////////////////////////////////////////////////
struct while_continuation {};
/// @}

//////////////////////////////////////////////////////////////////////
/// @defgroup skeletonsTagsCompositions Composed Skeletons Tags
/// @brief These tags are generally used in the spawning process to identify
/// various skeletons and to apply optimizations/transformations on them.
///
/// @{
//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify an @ref allgather skeleton.
//////////////////////////////////////////////////////////////////////
struct unnamed_skeleton {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify an @ref allgather skeleton.
//////////////////////////////////////////////////////////////////////
template <typename Tag>
struct allgather {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify an @ref allreduce skeleton.
//////////////////////////////////////////////////////////////////////
template <typename Tag>
struct allreduce {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify an @ref alltoall skeleton.
//////////////////////////////////////////////////////////////////////
template <typename Tag>
struct alltoall {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref binary_tree skeleton.
//////////////////////////////////////////////////////////////////////
template <typename Alignment>
struct binary_tree {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref binomial computation.
//////////////////////////////////////////////////////////////////////
struct binomial {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref binomial tree.
//////////////////////////////////////////////////////////////////////
template <typename Phase>
struct binomial_tree {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref bitonic sort.
//////////////////////////////////////////////////////////////////////
struct bitonic_sort {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a bitreversal skeleton.
//////////////////////////////////////////////////////////////////////
struct bitreversal {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify the type of scan skeletons as Blelloch.
//////////////////////////////////////////////////////////////////////
struct blelloch {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a broadcast skeleton.
//////////////////////////////////////////////////////////////////////
template <typename Alignment>
struct broadcast {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a broadcast to locations skeleton.
//////////////////////////////////////////////////////////////////////
struct broadcast_to_locs {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a butterfly skeleton.
//////////////////////////////////////////////////////////////////////
template <bool isFiltered = false>
struct butterfly {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a copy skeleton.
//////////////////////////////////////////////////////////////////////
struct copy {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify type of an @ref fft skeleton as DIF
//////////////////////////////////////////////////////////////////////
struct dif {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify type of an @ref fft skeleton as DIT
//////////////////////////////////////////////////////////////////////
struct dit {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify type of a do_while operator
//////////////////////////////////////////////////////////////////////
struct do_while {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify exclusive operations such as in scan.
//////////////////////////////////////////////////////////////////////
struct exclusive {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify an @c expand_from_pow_two skeleton
//////////////////////////////////////////////////////////////////////
struct expand_from_pow_two {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify flat operations such as in
/// a @ref alltoall skeletons.
//////////////////////////////////////////////////////////////////////
struct flat {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify an @ref fft skeleton
//////////////////////////////////////////////////////////////////////
template <typename Tag>
struct fft {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify an @ref gather skeleton.
//////////////////////////////////////////////////////////////////////
template <typename Tag>
struct gather {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify the type of scan skeleton as
/// Hillis-Steele.
//////////////////////////////////////////////////////////////////////
struct hillis_steele {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify hybrid operations such as in
/// a @ref alltoall skeleton
//////////////////////////////////////////////////////////////////////
struct hybrid {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify inclusive operations such as in scan.
//////////////////////////////////////////////////////////////////////
struct inclusive {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify the type of scan skeleton as
/// the one listed in Joseph Jaja's parallel algorithm text.
//////////////////////////////////////////////////////////////////////
struct jaja {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref map skeleton.
//////////////////////////////////////////////////////////////////////
template <bool isFiltered = false>
struct map {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref map_reduce skeleton.
//////////////////////////////////////////////////////////////////////
struct map_reduce {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref matrix_multiply skeleton.
//////////////////////////////////////////////////////////////////////
template <typename Tag>
struct matrix_multiply {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref notify_map skeleton.
//////////////////////////////////////////////////////////////////////
template <int NotifCount>
struct notify_map {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref odd_even_merge_sort.
//////////////////////////////////////////////////////////////////////
struct odd_even_merge_sort {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a pairwise exchange operations such
/// as in @c alltoall
//////////////////////////////////////////////////////////////////////
struct pairwise_exchange {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref pointer_jumping skeleton.
//////////////////////////////////////////////////////////////////////
struct pointer_jumping {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref pre_broadcast skeleton.
//////////////////////////////////////////////////////////////////////
struct pre_broadcast {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref reduce skeleton.
//////////////////////////////////////////////////////////////////////
template <typename Alignment>
struct reduce {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref reduce_to_locs skeleton.
//////////////////////////////////////////////////////////////////////
struct reduce_to_locs {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref reduce_to_pow_two skeleton.
//////////////////////////////////////////////////////////////////////
struct reduce_to_pow_two {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref reverse_butterfly skeleton.
//////////////////////////////////////////////////////////////////////
template <bool isFiltered = false>
struct reverse_butterfly {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref reverse_binary_tree skeleton.
//////////////////////////////////////////////////////////////////////
template <typename Alignment>
struct reverse_binary_tree {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref reverse_tree skeleton.
//////////////////////////////////////////////////////////////////////
template <int i>
struct reverse_tree {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref serial skeleton.
//////////////////////////////////////////////////////////////////////
template <int i>
struct serial {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref scan skeleton.
//////////////////////////////////////////////////////////////////////
template <typename Algorithm, typename Type=tags::inclusive>
struct scan {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref scan_reduce skeleton.
//////////////////////////////////////////////////////////////////////
template <typename Algorithm, typename Type=tags::inclusive>
struct scan_reduce {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify an @ref scatter skeleton.
//////////////////////////////////////////////////////////////////////
template <typename Tag>
struct scatter {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify an @ref set_result skeleton.
//////////////////////////////////////////////////////////////////////
struct set_result {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref sink skeleton.
//////////////////////////////////////////////////////////////////////
struct sink {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref SUMMA skeleton.
//////////////////////////////////////////////////////////////////////
struct summa {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref transpose_2d skeleton.
//////////////////////////////////////////////////////////////////////
struct transpose_2d {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref tree skeleton.
//////////////////////////////////////////////////////////////////////
template <int i>
struct tree {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref sink_value skeleton.
//////////////////////////////////////////////////////////////////////
template <typename inner_sk>
struct sink_value {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref stencil skeleton.
//////////////////////////////////////////////////////////////////////
template <int dim, int numPoints, bool isPeriodic = true>
struct stencil {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref wavefront skeleton.
//////////////////////////////////////////////////////////////////////
template <int i>
struct wavefront {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref zip skeleton.
//////////////////////////////////////////////////////////////////////
template <typename Tag, int arity>
struct zip {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a @ref zip_reduce skeleton.
//////////////////////////////////////////////////////////////////////
template <int arity>
struct zip_reduce {};

/// @}

//////////////////////////////////////////////////////////////////////
/// @defgroup skeletonsTagsWavefront Tags which determine corners of
/// an n-dimensional wavefront skeleton.
///
/// @{
//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify the first element in skeletons such
/// as a wavefront.
//////////////////////////////////////////////////////////////////////
struct first {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify the last element in skeletons such
/// as a wavefront.
//////////////////////////////////////////////////////////////////////
struct last {};

template <int... >
struct direction {};

/// @}

//////////////////////////////////////////////////////////////////////
/// @defgroup skeletonsTagsTrees Tags of Tree-type Skeletons
/// @brief These tags are used in the Skeletons Framework to identify the
/// various types of tree-based skeletons such as @ref reduce, @ref broadcast.
///
/// @{
//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a left-aligned tree.
//////////////////////////////////////////////////////////////////////
struct left_aligned {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a left-skewed tree.
//////////////////////////////////////////////////////////////////////
struct left_skewed {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a right-aligned tree.
//////////////////////////////////////////////////////////////////////
struct right_aligned {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a right-skewed tree.
//////////////////////////////////////////////////////////////////////
struct right_skewed {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify an up-phase tree in skeletons such as
/// a binomial tree.
//////////////////////////////////////////////////////////////////////
struct up_phase {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a down-phase tree in skeletons such as
/// a binomial tree.
//////////////////////////////////////////////////////////////////////
struct down_phase {};

/// @}

//////////////////////////////////////////////////////////////////////
/// @defgroup skeletonsTagsCoarse Coarsening Transformation Tags
/// @brief These tags are used in the coarsening process in order to specify
/// algorithm transformation on skeletons.
///
/// @{
//tags needed for customization of coarsening

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a coarsening operation.
//////////////////////////////////////////////////////////////////////
struct coarsening_tag {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify the type of coarsening operation.
//////////////////////////////////////////////////////////////////////
template <typename Tag, typename ExecutionTag>
struct coarse {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a nesting transformation.
//////////////////////////////////////////////////////////////////////
struct nest {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a nesting transformation.
//////////////////////////////////////////////////////////////////////
struct recursive_nest {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a naive coarsening operation.
//////////////////////////////////////////////////////////////////////
struct naive {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a no-coarsening.
//////////////////////////////////////////////////////////////////////
struct no_coarsening
  : public coarsening_tag
{ };

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify if a workfunction can handle coarsened
/// input data.
//////////////////////////////////////////////////////////////////////
struct with_coarsened_wf
  : public coarsening_tag
{ };

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to apply multiple transformations onto a skeleton.
//////////////////////////////////////////////////////////////////////
template <typename... Ts>
struct multipass_transform { };

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a zip-fusion transformation.
///
/// @see multipass_transform
//////////////////////////////////////////////////////////////////////
struct zip_fusion { };

/// @}

//////////////////////////////////////////////////////////////////////
/// @defgroup skeletonsTagsExecution Tags specifying the execution
/// method for a wrapped skeleton in a @c @ref wrapped_skeleton
///
/// @{
//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a nest execution for @ref wrapped_skeleton.
//////////////////////////////////////////////////////////////////////
template <bool isReducerSkeleton = false>
struct nested_execution
{ };

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify a sequential execution for
/// @ref wrapped_skeleton.
//////////////////////////////////////////////////////////////////////
struct sequential_execution {};

struct sequential_execution_partial {};

struct only_boundary {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to refine sequential execution with a loop unroll
/// directive to the optimizer.
///
/// @tparam factor The unroll factor to employ in the optimizer.
//////////////////////////////////////////////////////////////////////
template <std::size_t factor>
struct sequential_unroll {};

/// @}

//////////////////////////////////////////////////////////////////////
/// @defgroup skeletonsTagsFactories Explicit Factories Tags
/// @brief These tags are used to tag explicit factories in order to specify
/// customized termination detection for them.
///
/// @{
//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify the explicit compositional map explicit
/// factory.
//////////////////////////////////////////////////////////////////////
struct composition_map {};
//////////////////////////////////////////////////////////////////////
/// @brief Tag type to identify the explicit nested map-reduce factory.
//////////////////////////////////////////////////////////////////////
struct nested_map_reduce {};

/// @}

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to specify that the flow type of a skeleton is to
/// be computed based on inputs.
/// @see flows::inline_flows::inline_flow
//////////////////////////////////////////////////////////////////////
struct inline_flow {};

//////////////////////////////////////////////////////////////////////
/// @brief Tag type to specify that the flow type of a skeleton is to
/// be computed based on inputs and the internal skeletons are to be
/// topologically sorted which ensures they can be executed in the
/// order they are spawned. This also will stop compilation if a cycle
/// is found.
/// @see flows::inline_flows::inline_flow
//////////////////////////////////////////////////////////////////////
struct sorted_inline_flow {};
/// @}
}
}
}

#endif // STAPL_SKELETONS_UTILITY_TAGS_HPP
